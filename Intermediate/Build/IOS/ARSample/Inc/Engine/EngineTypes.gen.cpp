// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "GeneratedCppIncludes.h"
#include "Classes/Engine/EngineTypes.h"
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeEngineTypes() {}
// Cross Module References
	ENGINE_API UFunction* Z_Construct_UDelegateFunction_Engine_ConstraintBrokenSignature__DelegateSignature();
	UPackage* Z_Construct_UPackage__Script_Engine();
	ENGINE_API UFunction* Z_Construct_UDelegateFunction_Engine_TimerDynamicDelegate__DelegateSignature();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EMeshBufferAccess();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ESpawnActorCollisionHandlingMethod();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EConstraintFrame();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EAngularConstraintMotion();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EComponentSocketType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EComponentMobility();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EPhysicalSurface();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EWalkableSlopeBehavior();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ERotatorQuantization();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EVectorQuantization();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EEndPlayReason();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EAutoPossessAI();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EAutoReceiveInput();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ENetDormancy();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ENetRole();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EUpdateRateShiftBucket();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EShadowMapFlags();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ELightMapPaddingType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ECollisionEnabled();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETimelineSigType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ESleepFamily();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ERadialImpulseFalloff();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EInputConsumeOptions();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EFilterInterpolationType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ECollisionResponse();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EPhysicsSceneType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETraceTypeQuery();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EObjectTypeQuery();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EOverlapFilterOption();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ECollisionChannel();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ENetworkSmoothingMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EMovementMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETriangleSortAxis();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETriangleSortOption();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ELightingBuildQuality();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EMaterialSamplerType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EMaterialTessellationMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EMaterialShadingModel();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EParticleCollisionMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETrailWidthMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EGBufferFormat();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ESceneCaptureCompositeMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ESceneCaptureSource();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETranslucentSortPolicy();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ERefractionMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ETranslucencyLightingMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ESamplerSourceMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EBlendMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EOcclusionCombineMode();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EAttachLocation();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EDetachmentRule();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EAttachmentRule();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EActorMetricsType();
	ENGINE_API UEnum* Z_Construct_UEnum_Engine_EAspectRatioAxisConstraint();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FUserActivity();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FCanvasUVTri();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FLinearColor();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FVector2D();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FFontRenderInfo();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FDepthFieldGlowInfo();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FDebugFloatHistory();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRedirector();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FCollectionReference();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FDirectoryPath();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FFilePath();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FComponentReference();
	ENGINE_API UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FConstrainComponentPropName();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FWalkableSlopeOverride();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRepAttachment();
	ENGINE_API UClass* Z_Construct_UClass_USceneComponent_NoRegister();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize100();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRepMovement();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FTimerHandle();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRadialDamageEvent();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FDamageEvent();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRadialDamageParams();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FPointDamageEvent();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantizeNormal();
	ENGINE_API UClass* Z_Construct_UClass_UDamageType_NoRegister();
	COREUOBJECT_API UClass* Z_Construct_UClass_UClass();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FMeshBuildSettings();
	ENGINE_API UClass* Z_Construct_UClass_UStaticMesh_NoRegister();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FPOV();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FAnimUpdateRateParameters();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotDesc();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotInfo();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FMTDResult();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FOverlapResult();
	ENGINE_API UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API UClass* Z_Construct_UClass_UPhysicalMaterial_NoRegister();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FPrimitiveMaterialRef();
	ENGINE_API UClass* Z_Construct_UClass_UDecalComponent_NoRegister();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FSwarmDebugOptions();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLightmassDebugOptions();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLightmassPrimitiveSettings();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLightmassLightSettings();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLightmassPointLightSettings();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLocalizedSubtitle();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FSubtitleCue();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FBasedPosition();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FFractureEffect();
	ENGINE_API UClass* Z_Construct_UClass_USoundBase_NoRegister();
	ENGINE_API UClass* Z_Construct_UClass_UParticleSystem_NoRegister();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FCollisionImpactData();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyContactInfo();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyErrorCorrection();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyState();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FQuat();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FCollisionResponseContainer();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FResponseChannel();
	ENGINE_API UScriptStruct* Z_Construct_UScriptStruct_FLightingChannels();
	ENGINE_API UClass* Z_Construct_UClass_UEngineTypes_NoRegister();
	ENGINE_API UClass* Z_Construct_UClass_UEngineTypes();
	COREUOBJECT_API UClass* Z_Construct_UClass_UObject();
// End Cross Module References
	UFunction* Z_Construct_UDelegateFunction_Engine_ConstraintBrokenSignature__DelegateSignature()
	{
		struct _Script_Engine_eventConstraintBrokenSignature_Parms
		{
			int32 ConstraintIndex;
		};
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_ConstraintIndex = { UE4CodeGen_Private::EPropertyClass::Int, "ConstraintIndex", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000080, 1, nullptr, STRUCT_OFFSET(_Script_Engine_eventConstraintBrokenSignature_Parms, ConstraintIndex), METADATA_PARAMS(nullptr, 0) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ConstraintIndex,
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Dynamic delegate to use by components that want to route the broken-event into blueprints" },
			};
#endif
			static const UE4CodeGen_Private::FFunctionParams FuncParams = { (UObject*(*)())Z_Construct_UPackage__Script_Engine, "ConstraintBrokenSignature__DelegateSignature", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x00130000, sizeof(_Script_Engine_eventConstraintBrokenSignature_Parms), PropPointers, ARRAY_COUNT(PropPointers), 0, 0, METADATA_PARAMS(Function_MetaDataParams, ARRAY_COUNT(Function_MetaDataParams)) };
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, FuncParams);
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_Engine_TimerDynamicDelegate__DelegateSignature()
	{
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFunctionParams FuncParams = { (UObject*(*)())Z_Construct_UPackage__Script_Engine, "TimerDynamicDelegate__DelegateSignature", RF_Public|RF_Transient|RF_MarkAsNative, nullptr, (EFunctionFlags)0x00120000, 0, nullptr, 0, 0, 0, METADATA_PARAMS(Function_MetaDataParams, ARRAY_COUNT(Function_MetaDataParams)) };
			UE4CodeGen_Private::ConstructUFunction(ReturnFunction, FuncParams);
		}
		return ReturnFunction;
	}
	static UEnum* EMeshBufferAccess_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EMeshBufferAccess, Z_Construct_UPackage__Script_Engine(), TEXT("EMeshBufferAccess"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EMeshBufferAccess(EMeshBufferAccess_StaticEnum, TEXT("/Script/Engine"), TEXT("EMeshBufferAccess"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EMeshBufferAccess_CRC() { return 1372661648U; }
	UEnum* Z_Construct_UEnum_Engine_EMeshBufferAccess()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EMeshBufferAccess"), 0, Get_Z_Construct_UEnum_Engine_EMeshBufferAccess_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EMeshBufferAccess::Default", (int64)EMeshBufferAccess::Default },
				{ "EMeshBufferAccess::ForceCPUAndGPU", (int64)EMeshBufferAccess::ForceCPUAndGPU },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "Default.ToolTip", "Access will be determined based on the assets used in the mesh and hardware / software capability." },
				{ "ForceCPUAndGPU.ToolTip", "Force access on both CPU and GPU." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Which processors will have access to Mesh Vertex Buffers." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EMeshBufferAccess",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EMeshBufferAccess",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ESpawnActorCollisionHandlingMethod_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ESpawnActorCollisionHandlingMethod, Z_Construct_UPackage__Script_Engine(), TEXT("ESpawnActorCollisionHandlingMethod"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESpawnActorCollisionHandlingMethod(ESpawnActorCollisionHandlingMethod_StaticEnum, TEXT("/Script/Engine"), TEXT("ESpawnActorCollisionHandlingMethod"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ESpawnActorCollisionHandlingMethod_CRC() { return 3653422678U; }
	UEnum* Z_Construct_UEnum_Engine_ESpawnActorCollisionHandlingMethod()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESpawnActorCollisionHandlingMethod"), 0, Get_Z_Construct_UEnum_Engine_ESpawnActorCollisionHandlingMethod_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ESpawnActorCollisionHandlingMethod::Undefined", (int64)ESpawnActorCollisionHandlingMethod::Undefined },
				{ "ESpawnActorCollisionHandlingMethod::AlwaysSpawn", (int64)ESpawnActorCollisionHandlingMethod::AlwaysSpawn },
				{ "ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn", (int64)ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn },
				{ "ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding", (int64)ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding },
				{ "ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding", (int64)ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "AdjustIfPossibleButAlwaysSpawn.DisplayName", "Try To Adjust Location, But Always Spawn" },
				{ "AdjustIfPossibleButAlwaysSpawn.ToolTip", "Actor will try to find a nearby non-colliding location (based on shape components), but will always spawn even if one cannot be found." },
				{ "AdjustIfPossibleButDontSpawnIfColliding.DisplayName", "Try To Adjust Location, Don't Spawn If Still Colliding" },
				{ "AdjustIfPossibleButDontSpawnIfColliding.ToolTip", "Actor will try to find a nearby non-colliding location (based on shape components), but will NOT spawn unless one is found." },
				{ "AlwaysSpawn.DisplayName", "Always Spawn, Ignore Collisions" },
				{ "AlwaysSpawn.ToolTip", "Actor will spawn in desired location, regardless of collisions." },
				{ "BlueprintType", "true" },
				{ "DontSpawnIfColliding.DisplayName", "Do Not Spawn" },
				{ "DontSpawnIfColliding.ToolTip", "Actor will fail to spawn." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Defines available strategies for handling the case where an actor is spawned in such a way that it penetrates blocking collision." },
				{ "Undefined.DisplayName", "Default" },
				{ "Undefined.ToolTip", "Fall back to default settings." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ESpawnActorCollisionHandlingMethod",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"ESpawnActorCollisionHandlingMethod",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EConstraintFrame_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EConstraintFrame, Z_Construct_UPackage__Script_Engine(), TEXT("EConstraintFrame"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EConstraintFrame(EConstraintFrame_StaticEnum, TEXT("/Script/Engine"), TEXT("EConstraintFrame"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EConstraintFrame_CRC() { return 167782696U; }
	UEnum* Z_Construct_UEnum_Engine_EConstraintFrame()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EConstraintFrame"), 0, Get_Z_Construct_UEnum_Engine_EConstraintFrame_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EConstraintFrame::Frame1", (int64)EConstraintFrame::Frame1 },
				{ "EConstraintFrame::Frame2", (int64)EConstraintFrame::Frame2 },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Enum to indicate which frame we want." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EConstraintFrame",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EConstraintFrame::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EAngularConstraintMotion_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EAngularConstraintMotion, Z_Construct_UPackage__Script_Engine(), TEXT("EAngularConstraintMotion"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAngularConstraintMotion(EAngularConstraintMotion_StaticEnum, TEXT("/Script/Engine"), TEXT("EAngularConstraintMotion"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EAngularConstraintMotion_CRC() { return 3617246806U; }
	UEnum* Z_Construct_UEnum_Engine_EAngularConstraintMotion()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAngularConstraintMotion"), 0, Get_Z_Construct_UEnum_Engine_EAngularConstraintMotion_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ACM_Free", (int64)ACM_Free },
				{ "ACM_Limited", (int64)ACM_Limited },
				{ "ACM_Locked", (int64)ACM_Locked },
				{ "ACM_MAX", (int64)ACM_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ACM_Free.DisplayName", "Free" },
				{ "ACM_Free.ToolTip", "No constraint against this axis." },
				{ "ACM_Limited.DisplayName", "Limited" },
				{ "ACM_Limited.ToolTip", "Limited freedom along this axis." },
				{ "ACM_Locked.DisplayName", "Locked" },
				{ "ACM_Locked.ToolTip", "Fully constraint against this axis." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "ANGULAR DOF" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAngularConstraintMotion",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EAngularConstraintMotion",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EComponentSocketType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EComponentSocketType, Z_Construct_UPackage__Script_Engine(), TEXT("EComponentSocketType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EComponentSocketType(EComponentSocketType_StaticEnum, TEXT("/Script/Engine"), TEXT("EComponentSocketType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EComponentSocketType_CRC() { return 291765004U; }
	UEnum* Z_Construct_UEnum_Engine_EComponentSocketType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EComponentSocketType"), 0, Get_Z_Construct_UEnum_Engine_EComponentSocketType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EComponentSocketType::Invalid", (int64)EComponentSocketType::Invalid },
				{ "EComponentSocketType::Bone", (int64)EComponentSocketType::Bone },
				{ "EComponentSocketType::Socket", (int64)EComponentSocketType::Socket },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "Bone.ToolTip", "Skeletal bone." },
				{ "Invalid.ToolTip", "Not a valid socket or bone name." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "Socket.ToolTip", "Socket." },
				{ "ToolTip", "Type of a socket on a scene component." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EComponentSocketType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EComponentSocketType::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EComponentMobility_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EComponentMobility, Z_Construct_UPackage__Script_Engine(), TEXT("EComponentMobility"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EComponentMobility(EComponentMobility_StaticEnum, TEXT("/Script/Engine"), TEXT("EComponentMobility"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EComponentMobility_CRC() { return 987644202U; }
	UEnum* Z_Construct_UEnum_Engine_EComponentMobility()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EComponentMobility"), 0, Get_Z_Construct_UEnum_Engine_EComponentMobility_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EComponentMobility::Static", (int64)EComponentMobility::Static },
				{ "EComponentMobility::Stationary", (int64)EComponentMobility::Stationary },
				{ "EComponentMobility::Movable", (int64)EComponentMobility::Movable },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "Movable.ToolTip", "Movable objects can be moved and changed in game.\n- Totally dynamic\n- Can cast dynamic shadows\n- Slowest rendering" },
				{ "Static.ToolTip", "Static objects cannot be moved or changed in game.\n- Allows baked lighting\n- Fastest rendering" },
				{ "Stationary.ToolTip", "A stationary light will only have its shadowing and bounced lighting from static geometry baked by Lightmass, all other lighting will be dynamic.\n- It can change color and intensity in game.\n- Can't move\n- Allows partial baked lighting\n- Dynamic shadows" },
				{ "ToolTip", "Describes how often this component is allowed to move." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EComponentMobility",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EComponentMobility::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EPhysicalSurface_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EPhysicalSurface, Z_Construct_UPackage__Script_Engine(), TEXT("EPhysicalSurface"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EPhysicalSurface(EPhysicalSurface_StaticEnum, TEXT("/Script/Engine"), TEXT("EPhysicalSurface"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EPhysicalSurface_CRC() { return 4272258074U; }
	UEnum* Z_Construct_UEnum_Engine_EPhysicalSurface()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EPhysicalSurface"), 0, Get_Z_Construct_UEnum_Engine_EPhysicalSurface_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SurfaceType_Default", (int64)SurfaceType_Default },
				{ "SurfaceType1", (int64)SurfaceType1 },
				{ "SurfaceType2", (int64)SurfaceType2 },
				{ "SurfaceType3", (int64)SurfaceType3 },
				{ "SurfaceType4", (int64)SurfaceType4 },
				{ "SurfaceType5", (int64)SurfaceType5 },
				{ "SurfaceType6", (int64)SurfaceType6 },
				{ "SurfaceType7", (int64)SurfaceType7 },
				{ "SurfaceType8", (int64)SurfaceType8 },
				{ "SurfaceType9", (int64)SurfaceType9 },
				{ "SurfaceType10", (int64)SurfaceType10 },
				{ "SurfaceType11", (int64)SurfaceType11 },
				{ "SurfaceType12", (int64)SurfaceType12 },
				{ "SurfaceType13", (int64)SurfaceType13 },
				{ "SurfaceType14", (int64)SurfaceType14 },
				{ "SurfaceType15", (int64)SurfaceType15 },
				{ "SurfaceType16", (int64)SurfaceType16 },
				{ "SurfaceType17", (int64)SurfaceType17 },
				{ "SurfaceType18", (int64)SurfaceType18 },
				{ "SurfaceType19", (int64)SurfaceType19 },
				{ "SurfaceType20", (int64)SurfaceType20 },
				{ "SurfaceType21", (int64)SurfaceType21 },
				{ "SurfaceType22", (int64)SurfaceType22 },
				{ "SurfaceType23", (int64)SurfaceType23 },
				{ "SurfaceType24", (int64)SurfaceType24 },
				{ "SurfaceType25", (int64)SurfaceType25 },
				{ "SurfaceType26", (int64)SurfaceType26 },
				{ "SurfaceType27", (int64)SurfaceType27 },
				{ "SurfaceType28", (int64)SurfaceType28 },
				{ "SurfaceType29", (int64)SurfaceType29 },
				{ "SurfaceType30", (int64)SurfaceType30 },
				{ "SurfaceType31", (int64)SurfaceType31 },
				{ "SurfaceType32", (int64)SurfaceType32 },
				{ "SurfaceType33", (int64)SurfaceType33 },
				{ "SurfaceType34", (int64)SurfaceType34 },
				{ "SurfaceType35", (int64)SurfaceType35 },
				{ "SurfaceType36", (int64)SurfaceType36 },
				{ "SurfaceType37", (int64)SurfaceType37 },
				{ "SurfaceType38", (int64)SurfaceType38 },
				{ "SurfaceType39", (int64)SurfaceType39 },
				{ "SurfaceType40", (int64)SurfaceType40 },
				{ "SurfaceType41", (int64)SurfaceType41 },
				{ "SurfaceType42", (int64)SurfaceType42 },
				{ "SurfaceType43", (int64)SurfaceType43 },
				{ "SurfaceType44", (int64)SurfaceType44 },
				{ "SurfaceType45", (int64)SurfaceType45 },
				{ "SurfaceType46", (int64)SurfaceType46 },
				{ "SurfaceType47", (int64)SurfaceType47 },
				{ "SurfaceType48", (int64)SurfaceType48 },
				{ "SurfaceType49", (int64)SurfaceType49 },
				{ "SurfaceType50", (int64)SurfaceType50 },
				{ "SurfaceType51", (int64)SurfaceType51 },
				{ "SurfaceType52", (int64)SurfaceType52 },
				{ "SurfaceType53", (int64)SurfaceType53 },
				{ "SurfaceType54", (int64)SurfaceType54 },
				{ "SurfaceType55", (int64)SurfaceType55 },
				{ "SurfaceType56", (int64)SurfaceType56 },
				{ "SurfaceType57", (int64)SurfaceType57 },
				{ "SurfaceType58", (int64)SurfaceType58 },
				{ "SurfaceType59", (int64)SurfaceType59 },
				{ "SurfaceType60", (int64)SurfaceType60 },
				{ "SurfaceType61", (int64)SurfaceType61 },
				{ "SurfaceType62", (int64)SurfaceType62 },
				{ "SurfaceType_Max", (int64)SurfaceType_Max },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SurfaceType1.Hidden", "" },
				{ "SurfaceType10.Hidden", "" },
				{ "SurfaceType11.Hidden", "" },
				{ "SurfaceType12.Hidden", "" },
				{ "SurfaceType13.Hidden", "" },
				{ "SurfaceType14.Hidden", "" },
				{ "SurfaceType15.Hidden", "" },
				{ "SurfaceType16.Hidden", "" },
				{ "SurfaceType17.Hidden", "" },
				{ "SurfaceType18.Hidden", "" },
				{ "SurfaceType19.Hidden", "" },
				{ "SurfaceType2.Hidden", "" },
				{ "SurfaceType20.Hidden", "" },
				{ "SurfaceType21.Hidden", "" },
				{ "SurfaceType22.Hidden", "" },
				{ "SurfaceType23.Hidden", "" },
				{ "SurfaceType24.Hidden", "" },
				{ "SurfaceType25.Hidden", "" },
				{ "SurfaceType26.Hidden", "" },
				{ "SurfaceType27.Hidden", "" },
				{ "SurfaceType28.Hidden", "" },
				{ "SurfaceType29.Hidden", "" },
				{ "SurfaceType3.Hidden", "" },
				{ "SurfaceType30.Hidden", "" },
				{ "SurfaceType31.Hidden", "" },
				{ "SurfaceType32.Hidden", "" },
				{ "SurfaceType33.Hidden", "" },
				{ "SurfaceType34.Hidden", "" },
				{ "SurfaceType35.Hidden", "" },
				{ "SurfaceType36.Hidden", "" },
				{ "SurfaceType37.Hidden", "" },
				{ "SurfaceType38.Hidden", "" },
				{ "SurfaceType39.Hidden", "" },
				{ "SurfaceType4.Hidden", "" },
				{ "SurfaceType40.Hidden", "" },
				{ "SurfaceType41.Hidden", "" },
				{ "SurfaceType42.Hidden", "" },
				{ "SurfaceType43.Hidden", "" },
				{ "SurfaceType44.Hidden", "" },
				{ "SurfaceType45.Hidden", "" },
				{ "SurfaceType46.Hidden", "" },
				{ "SurfaceType47.Hidden", "" },
				{ "SurfaceType48.Hidden", "" },
				{ "SurfaceType49.Hidden", "" },
				{ "SurfaceType5.Hidden", "" },
				{ "SurfaceType50.Hidden", "" },
				{ "SurfaceType51.Hidden", "" },
				{ "SurfaceType52.Hidden", "" },
				{ "SurfaceType53.Hidden", "" },
				{ "SurfaceType54.Hidden", "" },
				{ "SurfaceType55.Hidden", "" },
				{ "SurfaceType56.Hidden", "" },
				{ "SurfaceType57.Hidden", "" },
				{ "SurfaceType58.Hidden", "" },
				{ "SurfaceType59.Hidden", "" },
				{ "SurfaceType6.Hidden", "" },
				{ "SurfaceType60.Hidden", "" },
				{ "SurfaceType61.Hidden", "" },
				{ "SurfaceType62.Hidden", "" },
				{ "SurfaceType7.Hidden", "" },
				{ "SurfaceType8.Hidden", "" },
				{ "SurfaceType9.Hidden", "" },
				{ "SurfaceType_Default.DisplayName", "Default" },
				{ "SurfaceType_Max.Hidden", "" },
				{ "ToolTip", "Types of surfaces in the game." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EPhysicalSurface",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EPhysicalSurface",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EWalkableSlopeBehavior_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EWalkableSlopeBehavior, Z_Construct_UPackage__Script_Engine(), TEXT("EWalkableSlopeBehavior"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EWalkableSlopeBehavior(EWalkableSlopeBehavior_StaticEnum, TEXT("/Script/Engine"), TEXT("EWalkableSlopeBehavior"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EWalkableSlopeBehavior_CRC() { return 2726067099U; }
	UEnum* Z_Construct_UEnum_Engine_EWalkableSlopeBehavior()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EWalkableSlopeBehavior"), 0, Get_Z_Construct_UEnum_Engine_EWalkableSlopeBehavior_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "WalkableSlope_Default", (int64)WalkableSlope_Default },
				{ "WalkableSlope_Increase", (int64)WalkableSlope_Increase },
				{ "WalkableSlope_Decrease", (int64)WalkableSlope_Decrease },
				{ "WalkableSlope_Unwalkable", (int64)WalkableSlope_Unwalkable },
				{ "WalkableSlope_Max", (int64)WalkableSlope_Max },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Controls behavior of WalkableSlopeOverride, determining how to affect walkability of surfaces for Characters.\n@see FWalkableSlopeOverride\n@see UCharacterMovementComponent::GetWalkableFloorAngle(), UCharacterMovementComponent::SetWalkableFloorAngle()" },
				{ "WalkableSlope_Decrease.DisplayName", "Decrease Walkable Slope" },
				{ "WalkableSlope_Decrease.ToolTip", "Decrease walkable slope.\nMakes it harder to walk up a surface, by restricting traversal to lower-than-usual angles.\n@see FWalkableSlopeOverride::WalkableSlopeAngle" },
				{ "WalkableSlope_Default.DisplayName", "Unchanged" },
				{ "WalkableSlope_Default.ToolTip", "Don't affect the walkable slope. Walkable slope angle will be ignored." },
				{ "WalkableSlope_Increase.DisplayName", "Increase Walkable Slope" },
				{ "WalkableSlope_Increase.ToolTip", "Increase walkable slope.\nMakes it easier to walk up a surface, by allowing traversal over higher-than-usual angles.\n@see FWalkableSlopeOverride::WalkableSlopeAngle" },
				{ "WalkableSlope_Max.Hidden", "" },
				{ "WalkableSlope_Unwalkable.DisplayName", "Unwalkable" },
				{ "WalkableSlope_Unwalkable.ToolTip", "Make surface unwalkable.\nNote: WalkableSlopeAngle will be ignored." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EWalkableSlopeBehavior",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EWalkableSlopeBehavior",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ERotatorQuantization_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ERotatorQuantization, Z_Construct_UPackage__Script_Engine(), TEXT("ERotatorQuantization"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ERotatorQuantization(ERotatorQuantization_StaticEnum, TEXT("/Script/Engine"), TEXT("ERotatorQuantization"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ERotatorQuantization_CRC() { return 310480974U; }
	UEnum* Z_Construct_UEnum_Engine_ERotatorQuantization()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ERotatorQuantization"), 0, Get_Z_Construct_UEnum_Engine_ERotatorQuantization_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ERotatorQuantization::ByteComponents", (int64)ERotatorQuantization::ByteComponents },
				{ "ERotatorQuantization::ShortComponents", (int64)ERotatorQuantization::ShortComponents },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ByteComponents.ToolTip", "The rotator will be compressed to 8 bits per component." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ShortComponents.ToolTip", "The rotator will be compressed to 16 bits per component." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ERotatorQuantization",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"ERotatorQuantization",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EVectorQuantization_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EVectorQuantization, Z_Construct_UPackage__Script_Engine(), TEXT("EVectorQuantization"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EVectorQuantization(EVectorQuantization_StaticEnum, TEXT("/Script/Engine"), TEXT("EVectorQuantization"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EVectorQuantization_CRC() { return 3253490173U; }
	UEnum* Z_Construct_UEnum_Engine_EVectorQuantization()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EVectorQuantization"), 0, Get_Z_Construct_UEnum_Engine_EVectorQuantization_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EVectorQuantization::RoundWholeNumber", (int64)EVectorQuantization::RoundWholeNumber },
				{ "EVectorQuantization::RoundOneDecimal", (int64)EVectorQuantization::RoundOneDecimal },
				{ "EVectorQuantization::RoundTwoDecimals", (int64)EVectorQuantization::RoundTwoDecimals },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "RoundOneDecimal.ToolTip", "Each vector component will be rounded, preserving one decimal place." },
				{ "RoundTwoDecimals.ToolTip", "Each vector component will be rounded, preserving two decimal places." },
				{ "RoundWholeNumber.ToolTip", "Each vector component will be rounded to the nearest whole number." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EVectorQuantization",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EVectorQuantization",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EEndPlayReason_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EEndPlayReason, Z_Construct_UPackage__Script_Engine(), TEXT("EEndPlayReason"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEndPlayReason(EEndPlayReason_StaticEnum, TEXT("/Script/Engine"), TEXT("EEndPlayReason"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EEndPlayReason_CRC() { return 4290102555U; }
	UEnum* Z_Construct_UEnum_Engine_EEndPlayReason()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEndPlayReason"), 0, Get_Z_Construct_UEnum_Engine_EEndPlayReason_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EEndPlayReason::Destroyed", (int64)EEndPlayReason::Destroyed },
				{ "EEndPlayReason::LevelTransition", (int64)EEndPlayReason::LevelTransition },
				{ "EEndPlayReason::EndPlayInEditor", (int64)EEndPlayReason::EndPlayInEditor },
				{ "EEndPlayReason::RemovedFromWorld", (int64)EEndPlayReason::RemovedFromWorld },
				{ "EEndPlayReason::Quit", (int64)EEndPlayReason::Quit },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "Destroyed.ToolTip", "When the Actor or Component is explicitly destroyed." },
				{ "EndPlayInEditor.ToolTip", "When the world is being unloaded because PIE is ending." },
				{ "LevelTransition.ToolTip", "When the world is being unloaded for a level transition." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "Quit.ToolTip", "When the application is being exited." },
				{ "RemovedFromWorld.ToolTip", "When the level it is a member of is streamed out." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EEndPlayReason",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EEndPlayReason::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EAutoPossessAI_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EAutoPossessAI, Z_Construct_UPackage__Script_Engine(), TEXT("EAutoPossessAI"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAutoPossessAI(EAutoPossessAI_StaticEnum, TEXT("/Script/Engine"), TEXT("EAutoPossessAI"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EAutoPossessAI_CRC() { return 1192096392U; }
	UEnum* Z_Construct_UEnum_Engine_EAutoPossessAI()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAutoPossessAI"), 0, Get_Z_Construct_UEnum_Engine_EAutoPossessAI_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EAutoPossessAI::Disabled", (int64)EAutoPossessAI::Disabled },
				{ "EAutoPossessAI::PlacedInWorld", (int64)EAutoPossessAI::PlacedInWorld },
				{ "EAutoPossessAI::Spawned", (int64)EAutoPossessAI::Spawned },
				{ "EAutoPossessAI::PlacedInWorldOrSpawned", (int64)EAutoPossessAI::PlacedInWorldOrSpawned },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "Disabled.ToolTip", "Feature is disabled (do not automatically possess AI)." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "PlacedInWorld.ToolTip", "Only possess by an AI Controller if Pawn is placed in the world." },
				{ "PlacedInWorldOrSpawned.ToolTip", "Pawn is automatically possessed by an AI Controller whenever it is created." },
				{ "Spawned.ToolTip", "Only possess by an AI Controller if Pawn is spawned after the world has loaded." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAutoPossessAI",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EAutoPossessAI",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EAutoReceiveInput_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EAutoReceiveInput, Z_Construct_UPackage__Script_Engine(), TEXT("EAutoReceiveInput"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAutoReceiveInput(EAutoReceiveInput_StaticEnum, TEXT("/Script/Engine"), TEXT("EAutoReceiveInput"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EAutoReceiveInput_CRC() { return 2539694406U; }
	UEnum* Z_Construct_UEnum_Engine_EAutoReceiveInput()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAutoReceiveInput"), 0, Get_Z_Construct_UEnum_Engine_EAutoReceiveInput_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EAutoReceiveInput::Disabled", (int64)EAutoReceiveInput::Disabled },
				{ "EAutoReceiveInput::Player0", (int64)EAutoReceiveInput::Player0 },
				{ "EAutoReceiveInput::Player1", (int64)EAutoReceiveInput::Player1 },
				{ "EAutoReceiveInput::Player2", (int64)EAutoReceiveInput::Player2 },
				{ "EAutoReceiveInput::Player3", (int64)EAutoReceiveInput::Player3 },
				{ "EAutoReceiveInput::Player4", (int64)EAutoReceiveInput::Player4 },
				{ "EAutoReceiveInput::Player5", (int64)EAutoReceiveInput::Player5 },
				{ "EAutoReceiveInput::Player6", (int64)EAutoReceiveInput::Player6 },
				{ "EAutoReceiveInput::Player7", (int64)EAutoReceiveInput::Player7 },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAutoReceiveInput",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EAutoReceiveInput::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ENetDormancy_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ENetDormancy, Z_Construct_UPackage__Script_Engine(), TEXT("ENetDormancy"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ENetDormancy(ENetDormancy_StaticEnum, TEXT("/Script/Engine"), TEXT("ENetDormancy"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ENetDormancy_CRC() { return 2709004797U; }
	UEnum* Z_Construct_UEnum_Engine_ENetDormancy()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ENetDormancy"), 0, Get_Z_Construct_UEnum_Engine_ENetDormancy_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "DORM_Never", (int64)DORM_Never },
				{ "DORM_Awake", (int64)DORM_Awake },
				{ "DORM_DormantAll", (int64)DORM_DormantAll },
				{ "DORM_DormantPartial", (int64)DORM_DormantPartial },
				{ "DORM_Initial", (int64)DORM_Initial },
				{ "DORN_MAX", (int64)DORN_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "DORM_Awake.ToolTip", "This actor can go dormant, but is not currently dormant. Game code will tell it when it go dormant." },
				{ "DORM_DormantAll.ToolTip", "This actor wants to go fully dormant for all connections." },
				{ "DORM_DormantPartial.ToolTip", "This actor may want to go dormant for some connections, GetNetDormancy() will be called to find out which." },
				{ "DORM_Initial.ToolTip", "This actor is initially dormant for all connection if it was placed in map." },
				{ "DORM_Never.ToolTip", "This actor can never go network dormant." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ENetDormancy",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ENetDormancy",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ENetRole_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ENetRole, Z_Construct_UPackage__Script_Engine(), TEXT("ENetRole"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ENetRole(ENetRole_StaticEnum, TEXT("/Script/Engine"), TEXT("ENetRole"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ENetRole_CRC() { return 1823441861U; }
	UEnum* Z_Construct_UEnum_Engine_ENetRole()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ENetRole"), 0, Get_Z_Construct_UEnum_Engine_ENetRole_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ROLE_None", (int64)ROLE_None },
				{ "ROLE_SimulatedProxy", (int64)ROLE_SimulatedProxy },
				{ "ROLE_AutonomousProxy", (int64)ROLE_AutonomousProxy },
				{ "ROLE_Authority", (int64)ROLE_Authority },
				{ "ROLE_MAX", (int64)ROLE_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ROLE_Authority.ToolTip", "Authoritative control over the actor." },
				{ "ROLE_AutonomousProxy.ToolTip", "Locally autonomous proxy of this actor." },
				{ "ROLE_None.ToolTip", "No role at all." },
				{ "ROLE_SimulatedProxy.ToolTip", "Locally simulated proxy of this actor." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ENetRole",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ENetRole",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EUpdateRateShiftBucket_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EUpdateRateShiftBucket, Z_Construct_UPackage__Script_Engine(), TEXT("EUpdateRateShiftBucket"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EUpdateRateShiftBucket(EUpdateRateShiftBucket_StaticEnum, TEXT("/Script/Engine"), TEXT("EUpdateRateShiftBucket"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EUpdateRateShiftBucket_CRC() { return 3101685031U; }
	UEnum* Z_Construct_UEnum_Engine_EUpdateRateShiftBucket()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EUpdateRateShiftBucket"), 0, Get_Z_Construct_UEnum_Engine_EUpdateRateShiftBucket_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EUpdateRateShiftBucket::ShiftBucket0", (int64)EUpdateRateShiftBucket::ShiftBucket0 },
				{ "EUpdateRateShiftBucket::ShiftBucket1", (int64)EUpdateRateShiftBucket::ShiftBucket1 },
				{ "EUpdateRateShiftBucket::ShiftBucket2", (int64)EUpdateRateShiftBucket::ShiftBucket2 },
				{ "EUpdateRateShiftBucket::ShiftBucket3", (int64)EUpdateRateShiftBucket::ShiftBucket3 },
				{ "EUpdateRateShiftBucket::ShiftBucket4", (int64)EUpdateRateShiftBucket::ShiftBucket4 },
				{ "EUpdateRateShiftBucket::ShiftBucket5", (int64)EUpdateRateShiftBucket::ShiftBucket5 },
				{ "EUpdateRateShiftBucket::ShiftBucketMax", (int64)EUpdateRateShiftBucket::ShiftBucketMax },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Enum for controlling buckets for update rate optimizations if we need to stagger\nMultiple actor populations separately." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EUpdateRateShiftBucket",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EUpdateRateShiftBucket",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EShadowMapFlags_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EShadowMapFlags, Z_Construct_UPackage__Script_Engine(), TEXT("EShadowMapFlags"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EShadowMapFlags(EShadowMapFlags_StaticEnum, TEXT("/Script/Engine"), TEXT("EShadowMapFlags"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EShadowMapFlags_CRC() { return 2483884366U; }
	UEnum* Z_Construct_UEnum_Engine_EShadowMapFlags()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EShadowMapFlags"), 0, Get_Z_Construct_UEnum_Engine_EShadowMapFlags_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SMF_None", (int64)SMF_None },
				{ "SMF_Streamed", (int64)SMF_Streamed },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SMF_None.ToolTip", "No flags." },
				{ "SMF_Streamed.ToolTip", "Shadowmap should be placed in a streaming texture." },
				{ "ToolTip", "Bit-field flags that affects storage (e.g. packing, streaming) and other info about a shadowmap." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EShadowMapFlags",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EShadowMapFlags",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ELightMapPaddingType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ELightMapPaddingType, Z_Construct_UPackage__Script_Engine(), TEXT("ELightMapPaddingType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ELightMapPaddingType(ELightMapPaddingType_StaticEnum, TEXT("/Script/Engine"), TEXT("ELightMapPaddingType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ELightMapPaddingType_CRC() { return 3837025968U; }
	UEnum* Z_Construct_UEnum_Engine_ELightMapPaddingType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ELightMapPaddingType"), 0, Get_Z_Construct_UEnum_Engine_ELightMapPaddingType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "LMPT_NormalPadding", (int64)LMPT_NormalPadding },
				{ "LMPT_PrePadding", (int64)LMPT_PrePadding },
				{ "LMPT_NoPadding", (int64)LMPT_NoPadding },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ELightMapPaddingType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ELightMapPaddingType",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ECollisionEnabled_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ECollisionEnabled, Z_Construct_UPackage__Script_Engine(), TEXT("ECollisionEnabled"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ECollisionEnabled(ECollisionEnabled_StaticEnum, TEXT("/Script/Engine"), TEXT("ECollisionEnabled"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ECollisionEnabled_CRC() { return 2778840060U; }
	UEnum* Z_Construct_UEnum_Engine_ECollisionEnabled()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ECollisionEnabled"), 0, Get_Z_Construct_UEnum_Engine_ECollisionEnabled_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ECollisionEnabled::NoCollision", (int64)ECollisionEnabled::NoCollision },
				{ "ECollisionEnabled::QueryOnly", (int64)ECollisionEnabled::QueryOnly },
				{ "ECollisionEnabled::PhysicsOnly", (int64)ECollisionEnabled::PhysicsOnly },
				{ "ECollisionEnabled::QueryAndPhysics", (int64)ECollisionEnabled::QueryAndPhysics },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "NoCollision.DisplayName", "No Collision" },
				{ "NoCollision.ToolTip", "Will not create any representation in the physics engine. Cannot be used for spatial queries (raycasts, sweeps, overlaps) or simulation (rigid body, constraints). Best performance possible (especially for moving objects)" },
				{ "PhysicsOnly.DisplayName", "Physics Only (No Query Collision)" },
				{ "PhysicsOnly.ToolTip", "Only used only for physics simulation (rigid body, constraints). Cannot be used for spatial queries (raycasts, sweeps, overlaps). Useful for jiggly bits on characters that do not need per bone detection. Performance gains by keeping data out of query tree" },
				{ "QueryAndPhysics.DisplayName", "Collision Enabled (Query and Physics)" },
				{ "QueryAndPhysics.ToolTip", "Can be used for both spatial queries (raycasts, sweeps, overlaps) and simulation (rigid body, constraints)." },
				{ "QueryOnly.DisplayName", "Query Only (No Physics Collision)" },
				{ "QueryOnly.ToolTip", "Only used for spatial queries (raycasts, sweeps, and overlaps). Cannot be used for simulation (rigid body, constraints). Useful for character movement and things that do not need physical simulation. Performance gains by keeping data out of simulation tree." },
				{ "ToolTip", "Enum used to describe what type of collision is enabled on a body." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ECollisionEnabled",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"ECollisionEnabled::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETimelineSigType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETimelineSigType, Z_Construct_UPackage__Script_Engine(), TEXT("ETimelineSigType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETimelineSigType(ETimelineSigType_StaticEnum, TEXT("/Script/Engine"), TEXT("ETimelineSigType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETimelineSigType_CRC() { return 750946708U; }
	UEnum* Z_Construct_UEnum_Engine_ETimelineSigType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETimelineSigType"), 0, Get_Z_Construct_UEnum_Engine_ETimelineSigType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ETS_EventSignature", (int64)ETS_EventSignature },
				{ "ETS_FloatSignature", (int64)ETS_FloatSignature },
				{ "ETS_VectorSignature", (int64)ETS_VectorSignature },
				{ "ETS_LinearColorSignature", (int64)ETS_LinearColorSignature },
				{ "ETS_InvalidSignature", (int64)ETS_InvalidSignature },
				{ "ETS_MAX", (int64)ETS_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Enum used to indicate what type of timeline signature a function matches." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETimelineSigType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ETimelineSigType",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ESleepFamily_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ESleepFamily, Z_Construct_UPackage__Script_Engine(), TEXT("ESleepFamily"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESleepFamily(ESleepFamily_StaticEnum, TEXT("/Script/Engine"), TEXT("ESleepFamily"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ESleepFamily_CRC() { return 3442485104U; }
	UEnum* Z_Construct_UEnum_Engine_ESleepFamily()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESleepFamily"), 0, Get_Z_Construct_UEnum_Engine_ESleepFamily_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ESleepFamily::Normal", (int64)ESleepFamily::Normal },
				{ "ESleepFamily::Sensitive", (int64)ESleepFamily::Sensitive },
				{ "ESleepFamily::Custom", (int64)ESleepFamily::Custom },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "Custom.ToolTip", "Specify your own sleep threshold multiplier" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "Normal.ToolTip", "Engine defaults." },
				{ "Sensitive.ToolTip", "A family of values with a lower sleep threshold; good for slower pendulum-like physics." },
				{ "ToolTip", "Presets of values used in considering when put this body to sleep." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ESleepFamily",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"ESleepFamily",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ERadialImpulseFalloff_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ERadialImpulseFalloff, Z_Construct_UPackage__Script_Engine(), TEXT("ERadialImpulseFalloff"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ERadialImpulseFalloff(ERadialImpulseFalloff_StaticEnum, TEXT("/Script/Engine"), TEXT("ERadialImpulseFalloff"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ERadialImpulseFalloff_CRC() { return 519964613U; }
	UEnum* Z_Construct_UEnum_Engine_ERadialImpulseFalloff()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ERadialImpulseFalloff"), 0, Get_Z_Construct_UEnum_Engine_ERadialImpulseFalloff_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "RIF_Constant", (int64)RIF_Constant },
				{ "RIF_Linear", (int64)RIF_Linear },
				{ "RIF_MAX", (int64)RIF_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "RIF_Constant.ToolTip", "Impulse is a constant strength, up to the limit of its range." },
				{ "RIF_Linear.ToolTip", "Impulse should get linearly weaker the further from origin." },
				{ "ToolTip", "Enum for controlling the falloff of strength of a radial impulse as a function of distance from Origin." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ERadialImpulseFalloff",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ERadialImpulseFalloff",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EInputConsumeOptions_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EInputConsumeOptions, Z_Construct_UPackage__Script_Engine(), TEXT("EInputConsumeOptions"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EInputConsumeOptions(EInputConsumeOptions_StaticEnum, TEXT("/Script/Engine"), TEXT("EInputConsumeOptions"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EInputConsumeOptions_CRC() { return 280671356U; }
	UEnum* Z_Construct_UEnum_Engine_EInputConsumeOptions()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EInputConsumeOptions"), 0, Get_Z_Construct_UEnum_Engine_EInputConsumeOptions_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ICO_ConsumeAll", (int64)ICO_ConsumeAll },
				{ "ICO_ConsumeBoundKeys", (int64)ICO_ConsumeBoundKeys },
				{ "ICO_ConsumeNone", (int64)ICO_ConsumeNone },
				{ "ICO_MAX", (int64)ICO_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ICO_ConsumeAll.ToolTip", "This component consumes all input and no components lower in the stack are processed." },
				{ "ICO_ConsumeBoundKeys.ToolTip", "This component consumes all events for a keys it has bound (whether or not they are handled successfully).  Components lower in the stack will not receive events from these keys." },
				{ "ICO_ConsumeNone.ToolTip", "All input events will be available to components lower in the stack." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EInputConsumeOptions",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EInputConsumeOptions",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EFilterInterpolationType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EFilterInterpolationType, Z_Construct_UPackage__Script_Engine(), TEXT("EFilterInterpolationType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EFilterInterpolationType(EFilterInterpolationType_StaticEnum, TEXT("/Script/Engine"), TEXT("EFilterInterpolationType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EFilterInterpolationType_CRC() { return 3839357289U; }
	UEnum* Z_Construct_UEnum_Engine_EFilterInterpolationType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EFilterInterpolationType"), 0, Get_Z_Construct_UEnum_Engine_EFilterInterpolationType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "BSIT_Average", (int64)BSIT_Average },
				{ "BSIT_Linear", (int64)BSIT_Linear },
				{ "BSIT_Cubic", (int64)BSIT_Cubic },
				{ "BSIT_MAX", (int64)BSIT_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BSIT_Average.DisplayName", "Averaged Interpolation" },
				{ "BSIT_Cubic.DisplayName", "Cubic Interpolation" },
				{ "BSIT_Linear.DisplayName", "Linear Interpolation" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EFilterInterpolationType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EFilterInterpolationType",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ECollisionResponse_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ECollisionResponse, Z_Construct_UPackage__Script_Engine(), TEXT("ECollisionResponse"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ECollisionResponse(ECollisionResponse_StaticEnum, TEXT("/Script/Engine"), TEXT("ECollisionResponse"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ECollisionResponse_CRC() { return 1506191458U; }
	UEnum* Z_Construct_UEnum_Engine_ECollisionResponse()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ECollisionResponse"), 0, Get_Z_Construct_UEnum_Engine_ECollisionResponse_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ECR_Ignore", (int64)ECR_Ignore },
				{ "ECR_Overlap", (int64)ECR_Overlap },
				{ "ECR_Block", (int64)ECR_Block },
				{ "ECR_MAX", (int64)ECR_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ECR_Block.DisplayName", "Block" },
				{ "ECR_Ignore.DisplayName", "Ignore" },
				{ "ECR_Overlap.DisplayName", "Overlap" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Enum indicating how each type should respond" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ECollisionResponse",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ECollisionResponse",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EPhysicsSceneType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EPhysicsSceneType, Z_Construct_UPackage__Script_Engine(), TEXT("EPhysicsSceneType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EPhysicsSceneType(EPhysicsSceneType_StaticEnum, TEXT("/Script/Engine"), TEXT("EPhysicsSceneType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EPhysicsSceneType_CRC() { return 3173651332U; }
	UEnum* Z_Construct_UEnum_Engine_EPhysicsSceneType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EPhysicsSceneType"), 0, Get_Z_Construct_UEnum_Engine_EPhysicsSceneType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "PST_Sync", (int64)PST_Sync },
				{ "PST_Cloth", (int64)PST_Cloth },
				{ "PST_Async", (int64)PST_Async },
				{ "PST_MAX", (int64)PST_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "PST_Async.ToolTip", "The asynchronous scene, which may run while Unreal simulation code runs." },
				{ "PST_Cloth.ToolTip", "The cloth scene, which may run while Unreal simulation code runs." },
				{ "PST_Sync.ToolTip", "The synchronous scene, which must finish before Unreal simulation code is run." },
				{ "ToolTip", "Enum indicating which physics scene to use." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EPhysicsSceneType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EPhysicsSceneType",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETraceTypeQuery_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETraceTypeQuery, Z_Construct_UPackage__Script_Engine(), TEXT("ETraceTypeQuery"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETraceTypeQuery(ETraceTypeQuery_StaticEnum, TEXT("/Script/Engine"), TEXT("ETraceTypeQuery"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETraceTypeQuery_CRC() { return 279405167U; }
	UEnum* Z_Construct_UEnum_Engine_ETraceTypeQuery()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETraceTypeQuery"), 0, Get_Z_Construct_UEnum_Engine_ETraceTypeQuery_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "TraceTypeQuery1", (int64)TraceTypeQuery1 },
				{ "TraceTypeQuery2", (int64)TraceTypeQuery2 },
				{ "TraceTypeQuery3", (int64)TraceTypeQuery3 },
				{ "TraceTypeQuery4", (int64)TraceTypeQuery4 },
				{ "TraceTypeQuery5", (int64)TraceTypeQuery5 },
				{ "TraceTypeQuery6", (int64)TraceTypeQuery6 },
				{ "TraceTypeQuery7", (int64)TraceTypeQuery7 },
				{ "TraceTypeQuery8", (int64)TraceTypeQuery8 },
				{ "TraceTypeQuery9", (int64)TraceTypeQuery9 },
				{ "TraceTypeQuery10", (int64)TraceTypeQuery10 },
				{ "TraceTypeQuery11", (int64)TraceTypeQuery11 },
				{ "TraceTypeQuery12", (int64)TraceTypeQuery12 },
				{ "TraceTypeQuery13", (int64)TraceTypeQuery13 },
				{ "TraceTypeQuery14", (int64)TraceTypeQuery14 },
				{ "TraceTypeQuery15", (int64)TraceTypeQuery15 },
				{ "TraceTypeQuery16", (int64)TraceTypeQuery16 },
				{ "TraceTypeQuery17", (int64)TraceTypeQuery17 },
				{ "TraceTypeQuery18", (int64)TraceTypeQuery18 },
				{ "TraceTypeQuery19", (int64)TraceTypeQuery19 },
				{ "TraceTypeQuery20", (int64)TraceTypeQuery20 },
				{ "TraceTypeQuery21", (int64)TraceTypeQuery21 },
				{ "TraceTypeQuery22", (int64)TraceTypeQuery22 },
				{ "TraceTypeQuery23", (int64)TraceTypeQuery23 },
				{ "TraceTypeQuery24", (int64)TraceTypeQuery24 },
				{ "TraceTypeQuery25", (int64)TraceTypeQuery25 },
				{ "TraceTypeQuery26", (int64)TraceTypeQuery26 },
				{ "TraceTypeQuery27", (int64)TraceTypeQuery27 },
				{ "TraceTypeQuery28", (int64)TraceTypeQuery28 },
				{ "TraceTypeQuery29", (int64)TraceTypeQuery29 },
				{ "TraceTypeQuery30", (int64)TraceTypeQuery30 },
				{ "TraceTypeQuery31", (int64)TraceTypeQuery31 },
				{ "TraceTypeQuery32", (int64)TraceTypeQuery32 },
				{ "TraceTypeQuery_MAX", (int64)TraceTypeQuery_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "TraceTypeQuery1.Hidden", "" },
				{ "TraceTypeQuery10.Hidden", "" },
				{ "TraceTypeQuery11.Hidden", "" },
				{ "TraceTypeQuery12.Hidden", "" },
				{ "TraceTypeQuery13.Hidden", "" },
				{ "TraceTypeQuery14.Hidden", "" },
				{ "TraceTypeQuery15.Hidden", "" },
				{ "TraceTypeQuery16.Hidden", "" },
				{ "TraceTypeQuery17.Hidden", "" },
				{ "TraceTypeQuery18.Hidden", "" },
				{ "TraceTypeQuery19.Hidden", "" },
				{ "TraceTypeQuery2.Hidden", "" },
				{ "TraceTypeQuery20.Hidden", "" },
				{ "TraceTypeQuery21.Hidden", "" },
				{ "TraceTypeQuery22.Hidden", "" },
				{ "TraceTypeQuery23.Hidden", "" },
				{ "TraceTypeQuery24.Hidden", "" },
				{ "TraceTypeQuery25.Hidden", "" },
				{ "TraceTypeQuery26.Hidden", "" },
				{ "TraceTypeQuery27.Hidden", "" },
				{ "TraceTypeQuery28.Hidden", "" },
				{ "TraceTypeQuery29.Hidden", "" },
				{ "TraceTypeQuery3.Hidden", "" },
				{ "TraceTypeQuery30.Hidden", "" },
				{ "TraceTypeQuery31.Hidden", "" },
				{ "TraceTypeQuery32.Hidden", "" },
				{ "TraceTypeQuery4.Hidden", "" },
				{ "TraceTypeQuery5.Hidden", "" },
				{ "TraceTypeQuery6.Hidden", "" },
				{ "TraceTypeQuery7.Hidden", "" },
				{ "TraceTypeQuery8.Hidden", "" },
				{ "TraceTypeQuery9.Hidden", "" },
				{ "TraceTypeQuery_MAX.Hidden", "" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETraceTypeQuery",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ETraceTypeQuery",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EObjectTypeQuery_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EObjectTypeQuery, Z_Construct_UPackage__Script_Engine(), TEXT("EObjectTypeQuery"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EObjectTypeQuery(EObjectTypeQuery_StaticEnum, TEXT("/Script/Engine"), TEXT("EObjectTypeQuery"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EObjectTypeQuery_CRC() { return 1336513359U; }
	UEnum* Z_Construct_UEnum_Engine_EObjectTypeQuery()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EObjectTypeQuery"), 0, Get_Z_Construct_UEnum_Engine_EObjectTypeQuery_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ObjectTypeQuery1", (int64)ObjectTypeQuery1 },
				{ "ObjectTypeQuery2", (int64)ObjectTypeQuery2 },
				{ "ObjectTypeQuery3", (int64)ObjectTypeQuery3 },
				{ "ObjectTypeQuery4", (int64)ObjectTypeQuery4 },
				{ "ObjectTypeQuery5", (int64)ObjectTypeQuery5 },
				{ "ObjectTypeQuery6", (int64)ObjectTypeQuery6 },
				{ "ObjectTypeQuery7", (int64)ObjectTypeQuery7 },
				{ "ObjectTypeQuery8", (int64)ObjectTypeQuery8 },
				{ "ObjectTypeQuery9", (int64)ObjectTypeQuery9 },
				{ "ObjectTypeQuery10", (int64)ObjectTypeQuery10 },
				{ "ObjectTypeQuery11", (int64)ObjectTypeQuery11 },
				{ "ObjectTypeQuery12", (int64)ObjectTypeQuery12 },
				{ "ObjectTypeQuery13", (int64)ObjectTypeQuery13 },
				{ "ObjectTypeQuery14", (int64)ObjectTypeQuery14 },
				{ "ObjectTypeQuery15", (int64)ObjectTypeQuery15 },
				{ "ObjectTypeQuery16", (int64)ObjectTypeQuery16 },
				{ "ObjectTypeQuery17", (int64)ObjectTypeQuery17 },
				{ "ObjectTypeQuery18", (int64)ObjectTypeQuery18 },
				{ "ObjectTypeQuery19", (int64)ObjectTypeQuery19 },
				{ "ObjectTypeQuery20", (int64)ObjectTypeQuery20 },
				{ "ObjectTypeQuery21", (int64)ObjectTypeQuery21 },
				{ "ObjectTypeQuery22", (int64)ObjectTypeQuery22 },
				{ "ObjectTypeQuery23", (int64)ObjectTypeQuery23 },
				{ "ObjectTypeQuery24", (int64)ObjectTypeQuery24 },
				{ "ObjectTypeQuery25", (int64)ObjectTypeQuery25 },
				{ "ObjectTypeQuery26", (int64)ObjectTypeQuery26 },
				{ "ObjectTypeQuery27", (int64)ObjectTypeQuery27 },
				{ "ObjectTypeQuery28", (int64)ObjectTypeQuery28 },
				{ "ObjectTypeQuery29", (int64)ObjectTypeQuery29 },
				{ "ObjectTypeQuery30", (int64)ObjectTypeQuery30 },
				{ "ObjectTypeQuery31", (int64)ObjectTypeQuery31 },
				{ "ObjectTypeQuery32", (int64)ObjectTypeQuery32 },
				{ "ObjectTypeQuery_MAX", (int64)ObjectTypeQuery_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ObjectTypeQuery1.Hidden", "" },
				{ "ObjectTypeQuery10.Hidden", "" },
				{ "ObjectTypeQuery11.Hidden", "" },
				{ "ObjectTypeQuery12.Hidden", "" },
				{ "ObjectTypeQuery13.Hidden", "" },
				{ "ObjectTypeQuery14.Hidden", "" },
				{ "ObjectTypeQuery15.Hidden", "" },
				{ "ObjectTypeQuery16.Hidden", "" },
				{ "ObjectTypeQuery17.Hidden", "" },
				{ "ObjectTypeQuery18.Hidden", "" },
				{ "ObjectTypeQuery19.Hidden", "" },
				{ "ObjectTypeQuery2.Hidden", "" },
				{ "ObjectTypeQuery20.Hidden", "" },
				{ "ObjectTypeQuery21.Hidden", "" },
				{ "ObjectTypeQuery22.Hidden", "" },
				{ "ObjectTypeQuery23.Hidden", "" },
				{ "ObjectTypeQuery24.Hidden", "" },
				{ "ObjectTypeQuery25.Hidden", "" },
				{ "ObjectTypeQuery26.Hidden", "" },
				{ "ObjectTypeQuery27.Hidden", "" },
				{ "ObjectTypeQuery28.Hidden", "" },
				{ "ObjectTypeQuery29.Hidden", "" },
				{ "ObjectTypeQuery3.Hidden", "" },
				{ "ObjectTypeQuery30.Hidden", "" },
				{ "ObjectTypeQuery31.Hidden", "" },
				{ "ObjectTypeQuery32.Hidden", "" },
				{ "ObjectTypeQuery4.Hidden", "" },
				{ "ObjectTypeQuery5.Hidden", "" },
				{ "ObjectTypeQuery6.Hidden", "" },
				{ "ObjectTypeQuery7.Hidden", "" },
				{ "ObjectTypeQuery8.Hidden", "" },
				{ "ObjectTypeQuery9.Hidden", "" },
				{ "ObjectTypeQuery_MAX.Hidden", "" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EObjectTypeQuery",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EObjectTypeQuery",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EOverlapFilterOption_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EOverlapFilterOption, Z_Construct_UPackage__Script_Engine(), TEXT("EOverlapFilterOption"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EOverlapFilterOption(EOverlapFilterOption_StaticEnum, TEXT("/Script/Engine"), TEXT("EOverlapFilterOption"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EOverlapFilterOption_CRC() { return 3895023074U; }
	UEnum* Z_Construct_UEnum_Engine_EOverlapFilterOption()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EOverlapFilterOption"), 0, Get_Z_Construct_UEnum_Engine_EOverlapFilterOption_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "OverlapFilter_All", (int64)OverlapFilter_All },
				{ "OverlapFilter_DynamicOnly", (int64)OverlapFilter_DynamicOnly },
				{ "OverlapFilter_StaticOnly", (int64)OverlapFilter_StaticOnly },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "OverlapFilter_All.DisplayName", "AllObjects" },
				{ "OverlapFilter_All.ToolTip", "returns both overlaps with both dynamic and static components" },
				{ "OverlapFilter_DynamicOnly.DisplayName", "AllDynamicObjects" },
				{ "OverlapFilter_DynamicOnly.ToolTip", "returns only overlaps with dynamic actors (far fewer results in practice, much more efficient)" },
				{ "OverlapFilter_StaticOnly.DisplayName", "AllStaticObjects" },
				{ "OverlapFilter_StaticOnly.ToolTip", "returns only overlaps with static actors (fewer results, more efficient)" },
				{ "ToolTip", "@note, if you change this, change GetCollisionChannelFromOverlapFilter() to match" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EOverlapFilterOption",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EOverlapFilterOption",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ECollisionChannel_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ECollisionChannel, Z_Construct_UPackage__Script_Engine(), TEXT("ECollisionChannel"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ECollisionChannel(ECollisionChannel_StaticEnum, TEXT("/Script/Engine"), TEXT("ECollisionChannel"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ECollisionChannel_CRC() { return 3260719938U; }
	UEnum* Z_Construct_UEnum_Engine_ECollisionChannel()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ECollisionChannel"), 0, Get_Z_Construct_UEnum_Engine_ECollisionChannel_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ECC_WorldStatic", (int64)ECC_WorldStatic },
				{ "ECC_WorldDynamic", (int64)ECC_WorldDynamic },
				{ "ECC_Pawn", (int64)ECC_Pawn },
				{ "ECC_Visibility", (int64)ECC_Visibility },
				{ "ECC_Camera", (int64)ECC_Camera },
				{ "ECC_PhysicsBody", (int64)ECC_PhysicsBody },
				{ "ECC_Vehicle", (int64)ECC_Vehicle },
				{ "ECC_Destructible", (int64)ECC_Destructible },
				{ "ECC_EngineTraceChannel1", (int64)ECC_EngineTraceChannel1 },
				{ "ECC_EngineTraceChannel2", (int64)ECC_EngineTraceChannel2 },
				{ "ECC_EngineTraceChannel3", (int64)ECC_EngineTraceChannel3 },
				{ "ECC_EngineTraceChannel4", (int64)ECC_EngineTraceChannel4 },
				{ "ECC_EngineTraceChannel5", (int64)ECC_EngineTraceChannel5 },
				{ "ECC_EngineTraceChannel6", (int64)ECC_EngineTraceChannel6 },
				{ "ECC_GameTraceChannel1", (int64)ECC_GameTraceChannel1 },
				{ "ECC_GameTraceChannel2", (int64)ECC_GameTraceChannel2 },
				{ "ECC_GameTraceChannel3", (int64)ECC_GameTraceChannel3 },
				{ "ECC_GameTraceChannel4", (int64)ECC_GameTraceChannel4 },
				{ "ECC_GameTraceChannel5", (int64)ECC_GameTraceChannel5 },
				{ "ECC_GameTraceChannel6", (int64)ECC_GameTraceChannel6 },
				{ "ECC_GameTraceChannel7", (int64)ECC_GameTraceChannel7 },
				{ "ECC_GameTraceChannel8", (int64)ECC_GameTraceChannel8 },
				{ "ECC_GameTraceChannel9", (int64)ECC_GameTraceChannel9 },
				{ "ECC_GameTraceChannel10", (int64)ECC_GameTraceChannel10 },
				{ "ECC_GameTraceChannel11", (int64)ECC_GameTraceChannel11 },
				{ "ECC_GameTraceChannel12", (int64)ECC_GameTraceChannel12 },
				{ "ECC_GameTraceChannel13", (int64)ECC_GameTraceChannel13 },
				{ "ECC_GameTraceChannel14", (int64)ECC_GameTraceChannel14 },
				{ "ECC_GameTraceChannel15", (int64)ECC_GameTraceChannel15 },
				{ "ECC_GameTraceChannel16", (int64)ECC_GameTraceChannel16 },
				{ "ECC_GameTraceChannel17", (int64)ECC_GameTraceChannel17 },
				{ "ECC_GameTraceChannel18", (int64)ECC_GameTraceChannel18 },
				{ "ECC_OverlapAll_Deprecated", (int64)ECC_OverlapAll_Deprecated },
				{ "ECC_MAX", (int64)ECC_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ECC_Camera.DisplayName", "Camera" },
				{ "ECC_Camera.TraceQuery", "1" },
				{ "ECC_Destructible.DisplayName", "Destructible" },
				{ "ECC_EngineTraceChannel1.Hidden", "" },
				{ "ECC_EngineTraceChannel1.ToolTip", "Reserved for gizmo collision" },
				{ "ECC_EngineTraceChannel2.Hidden", "" },
				{ "ECC_EngineTraceChannel3.Hidden", "" },
				{ "ECC_EngineTraceChannel4.Hidden", "" },
				{ "ECC_EngineTraceChannel5.Hidden", "" },
				{ "ECC_EngineTraceChannel6.Hidden", "" },
				{ "ECC_GameTraceChannel1.Hidden", "" },
				{ "ECC_GameTraceChannel10.Hidden", "" },
				{ "ECC_GameTraceChannel11.Hidden", "" },
				{ "ECC_GameTraceChannel12.Hidden", "" },
				{ "ECC_GameTraceChannel13.Hidden", "" },
				{ "ECC_GameTraceChannel14.Hidden", "" },
				{ "ECC_GameTraceChannel15.Hidden", "" },
				{ "ECC_GameTraceChannel16.Hidden", "" },
				{ "ECC_GameTraceChannel17.Hidden", "" },
				{ "ECC_GameTraceChannel18.Hidden", "" },
				{ "ECC_GameTraceChannel2.Hidden", "" },
				{ "ECC_GameTraceChannel3.Hidden", "" },
				{ "ECC_GameTraceChannel4.Hidden", "" },
				{ "ECC_GameTraceChannel5.Hidden", "" },
				{ "ECC_GameTraceChannel6.Hidden", "" },
				{ "ECC_GameTraceChannel7.Hidden", "" },
				{ "ECC_GameTraceChannel8.Hidden", "" },
				{ "ECC_GameTraceChannel9.Hidden", "" },
				{ "ECC_OverlapAll_Deprecated.Hidden", "" },
				{ "ECC_OverlapAll_Deprecated.ToolTip", "Add only nonserialized/transient flags below // NOTE!!!! THESE ARE BEING DEPRECATED BUT STILL THERE FOR BLUEPRINT. PLEASE DO NOT USE THEM IN CODE" },
				{ "ECC_Pawn.DisplayName", "Pawn" },
				{ "ECC_PhysicsBody.DisplayName", "PhysicsBody" },
				{ "ECC_Vehicle.DisplayName", "Vehicle" },
				{ "ECC_Visibility.DisplayName", "Visibility" },
				{ "ECC_Visibility.TraceQuery", "1" },
				{ "ECC_WorldDynamic.DisplayName", "WorldDynamic" },
				{ "ECC_WorldStatic.DisplayName", "WorldStatic" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Enum indicating different type of objects for rigid-body collision purposes." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ECollisionChannel",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ECollisionChannel",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ENetworkSmoothingMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ENetworkSmoothingMode, Z_Construct_UPackage__Script_Engine(), TEXT("ENetworkSmoothingMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ENetworkSmoothingMode(ENetworkSmoothingMode_StaticEnum, TEXT("/Script/Engine"), TEXT("ENetworkSmoothingMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ENetworkSmoothingMode_CRC() { return 1606996781U; }
	UEnum* Z_Construct_UEnum_Engine_ENetworkSmoothingMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ENetworkSmoothingMode"), 0, Get_Z_Construct_UEnum_Engine_ENetworkSmoothingMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ENetworkSmoothingMode::Disabled", (int64)ENetworkSmoothingMode::Disabled },
				{ "ENetworkSmoothingMode::Linear", (int64)ENetworkSmoothingMode::Linear },
				{ "ENetworkSmoothingMode::Exponential", (int64)ENetworkSmoothingMode::Exponential },
				{ "ENetworkSmoothingMode::Replay", (int64)ENetworkSmoothingMode::Replay },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "Disabled.DisplayName", "Disabled" },
				{ "Disabled.ToolTip", "No smoothing, only change position as network position updates are received." },
				{ "Exponential.DisplayName", "Exponential" },
				{ "Exponential.ToolTip", "Exponential. Faster as you are further from target." },
				{ "Linear.DisplayName", "Linear" },
				{ "Linear.ToolTip", "Linear interpolation from source to target." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "Replay.DisplayName", "Replay" },
				{ "Replay.Hidden", "" },
				{ "Replay.ToolTip", "Special linear interpolation designed specifically for replays. Not intended as a selectable mode in-editor." },
				{ "ToolTip", "Smoothing approach used by network interpolation for Characters." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ENetworkSmoothingMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"ENetworkSmoothingMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EMovementMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EMovementMode, Z_Construct_UPackage__Script_Engine(), TEXT("EMovementMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EMovementMode(EMovementMode_StaticEnum, TEXT("/Script/Engine"), TEXT("EMovementMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EMovementMode_CRC() { return 3564642871U; }
	UEnum* Z_Construct_UEnum_Engine_EMovementMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EMovementMode"), 0, Get_Z_Construct_UEnum_Engine_EMovementMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "MOVE_None", (int64)MOVE_None },
				{ "MOVE_Walking", (int64)MOVE_Walking },
				{ "MOVE_NavWalking", (int64)MOVE_NavWalking },
				{ "MOVE_Falling", (int64)MOVE_Falling },
				{ "MOVE_Swimming", (int64)MOVE_Swimming },
				{ "MOVE_Flying", (int64)MOVE_Flying },
				{ "MOVE_Custom", (int64)MOVE_Custom },
				{ "MOVE_MAX", (int64)MOVE_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "MOVE_Custom.DisplayName", "Custom" },
				{ "MOVE_Custom.ToolTip", "User-defined custom movement mode, including many possible sub-modes." },
				{ "MOVE_Falling.DisplayName", "Falling" },
				{ "MOVE_Falling.ToolTip", "Falling under the effects of gravity, such as after jumping or walking off the edge of a surface." },
				{ "MOVE_Flying.DisplayName", "Flying" },
				{ "MOVE_Flying.ToolTip", "Flying, ignoring the effects of gravity. Affected by the current physics volume's fluid friction." },
				{ "MOVE_MAX.Hidden", "" },
				{ "MOVE_NavWalking.DisplayName", "Navmesh Walking" },
				{ "MOVE_NavWalking.ToolTip", "Simplified walking on navigation data (e.g. navmesh).\nIf bGenerateOverlapEvents is true, then we will perform sweeps with each navmesh move.\nIf bGenerateOverlapEvents is false then movement is cheaper but characters can overlap other objects without some extra process to repel/resolve their collisions." },
				{ "MOVE_None.DisplayName", "None" },
				{ "MOVE_None.ToolTip", "None (movement is disabled)." },
				{ "MOVE_Swimming.DisplayName", "Swimming" },
				{ "MOVE_Swimming.ToolTip", "Swimming through a fluid volume, under the effects of gravity and buoyancy." },
				{ "MOVE_Walking.DisplayName", "Walking" },
				{ "MOVE_Walking.ToolTip", "Walking on a surface." },
				{ "ToolTip", "Movement modes for Characters." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EMovementMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EMovementMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETriangleSortAxis_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETriangleSortAxis, Z_Construct_UPackage__Script_Engine(), TEXT("ETriangleSortAxis"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETriangleSortAxis(ETriangleSortAxis_StaticEnum, TEXT("/Script/Engine"), TEXT("ETriangleSortAxis"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETriangleSortAxis_CRC() { return 2991492717U; }
	UEnum* Z_Construct_UEnum_Engine_ETriangleSortAxis()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETriangleSortAxis"), 0, Get_Z_Construct_UEnum_Engine_ETriangleSortAxis_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "TSA_X_Axis", (int64)TSA_X_Axis },
				{ "TSA_Y_Axis", (int64)TSA_Y_Axis },
				{ "TSA_Z_Axis", (int64)TSA_Z_Axis },
				{ "TSA_MAX", (int64)TSA_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Enum to specify which axis to use for the forward vector when using TRISORT_CustomLeftRight sort mode." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETriangleSortAxis",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ETriangleSortAxis",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETriangleSortOption_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETriangleSortOption, Z_Construct_UPackage__Script_Engine(), TEXT("ETriangleSortOption"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETriangleSortOption(ETriangleSortOption_StaticEnum, TEXT("/Script/Engine"), TEXT("ETriangleSortOption"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETriangleSortOption_CRC() { return 2364258305U; }
	UEnum* Z_Construct_UEnum_Engine_ETriangleSortOption()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETriangleSortOption"), 0, Get_Z_Construct_UEnum_Engine_ETriangleSortOption_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "TRISORT_None", (int64)TRISORT_None },
				{ "TRISORT_CenterRadialDistance", (int64)TRISORT_CenterRadialDistance },
				{ "TRISORT_Random", (int64)TRISORT_Random },
				{ "TRISORT_MergeContiguous", (int64)TRISORT_MergeContiguous },
				{ "TRISORT_Custom", (int64)TRISORT_Custom },
				{ "TRISORT_CustomLeftRight", (int64)TRISORT_CustomLeftRight },
				{ "TRISORT_MAX", (int64)TRISORT_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETriangleSortOption",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ETriangleSortOption",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ELightingBuildQuality_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ELightingBuildQuality, Z_Construct_UPackage__Script_Engine(), TEXT("ELightingBuildQuality"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ELightingBuildQuality(ELightingBuildQuality_StaticEnum, TEXT("/Script/Engine"), TEXT("ELightingBuildQuality"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ELightingBuildQuality_CRC() { return 2343100384U; }
	UEnum* Z_Construct_UEnum_Engine_ELightingBuildQuality()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ELightingBuildQuality"), 0, Get_Z_Construct_UEnum_Engine_ELightingBuildQuality_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "Quality_Preview", (int64)Quality_Preview },
				{ "Quality_Medium", (int64)Quality_Medium },
				{ "Quality_High", (int64)Quality_High },
				{ "Quality_Production", (int64)Quality_Production },
				{ "Quality_MAX", (int64)Quality_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Lighting build quality enumeration" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ELightingBuildQuality",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ELightingBuildQuality",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EMaterialSamplerType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EMaterialSamplerType, Z_Construct_UPackage__Script_Engine(), TEXT("EMaterialSamplerType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EMaterialSamplerType(EMaterialSamplerType_StaticEnum, TEXT("/Script/Engine"), TEXT("EMaterialSamplerType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EMaterialSamplerType_CRC() { return 3311383514U; }
	UEnum* Z_Construct_UEnum_Engine_EMaterialSamplerType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EMaterialSamplerType"), 0, Get_Z_Construct_UEnum_Engine_EMaterialSamplerType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SAMPLERTYPE_Color", (int64)SAMPLERTYPE_Color },
				{ "SAMPLERTYPE_Grayscale", (int64)SAMPLERTYPE_Grayscale },
				{ "SAMPLERTYPE_Alpha", (int64)SAMPLERTYPE_Alpha },
				{ "SAMPLERTYPE_Normal", (int64)SAMPLERTYPE_Normal },
				{ "SAMPLERTYPE_Masks", (int64)SAMPLERTYPE_Masks },
				{ "SAMPLERTYPE_DistanceFieldFont", (int64)SAMPLERTYPE_DistanceFieldFont },
				{ "SAMPLERTYPE_LinearColor", (int64)SAMPLERTYPE_LinearColor },
				{ "SAMPLERTYPE_LinearGrayscale", (int64)SAMPLERTYPE_LinearGrayscale },
				{ "SAMPLERTYPE_External", (int64)SAMPLERTYPE_External },
				{ "SAMPLERTYPE_MAX", (int64)SAMPLERTYPE_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SAMPLERTYPE_Alpha.DisplayName", "Alpha" },
				{ "SAMPLERTYPE_Color.DisplayName", "Color" },
				{ "SAMPLERTYPE_DistanceFieldFont.DisplayName", "Distance Field Font" },
				{ "SAMPLERTYPE_External.DisplayName", "External" },
				{ "SAMPLERTYPE_Grayscale.DisplayName", "Grayscale" },
				{ "SAMPLERTYPE_LinearColor.DisplayName", "Linear Color" },
				{ "SAMPLERTYPE_LinearGrayscale.DisplayName", "Linear Grayscale" },
				{ "SAMPLERTYPE_Masks.DisplayName", "Masks" },
				{ "SAMPLERTYPE_Normal.DisplayName", "Normal" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EMaterialSamplerType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EMaterialSamplerType",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EMaterialTessellationMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EMaterialTessellationMode, Z_Construct_UPackage__Script_Engine(), TEXT("EMaterialTessellationMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EMaterialTessellationMode(EMaterialTessellationMode_StaticEnum, TEXT("/Script/Engine"), TEXT("EMaterialTessellationMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EMaterialTessellationMode_CRC() { return 2913306799U; }
	UEnum* Z_Construct_UEnum_Engine_EMaterialTessellationMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EMaterialTessellationMode"), 0, Get_Z_Construct_UEnum_Engine_EMaterialTessellationMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "MTM_NoTessellation", (int64)MTM_NoTessellation },
				{ "MTM_FlatTessellation", (int64)MTM_FlatTessellation },
				{ "MTM_PNTriangles", (int64)MTM_PNTriangles },
				{ "MTM_MAX", (int64)MTM_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "MTM_FlatTessellation.DisplayName", "Flat Tessellation" },
				{ "MTM_FlatTessellation.ToolTip", "Simple tessellation." },
				{ "MTM_NoTessellation.DisplayName", "No Tessellation" },
				{ "MTM_NoTessellation.ToolTip", "Tessellation disabled." },
				{ "MTM_PNTriangles.DisplayName", "PN Triangles" },
				{ "MTM_PNTriangles.ToolTip", "Simple spline based tessellation." },
				{ "ToolTip", "This is used by the drawing passes to determine tessellation policy, so changes here need to be supported in native code." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EMaterialTessellationMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EMaterialTessellationMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EMaterialShadingModel_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EMaterialShadingModel, Z_Construct_UPackage__Script_Engine(), TEXT("EMaterialShadingModel"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EMaterialShadingModel(EMaterialShadingModel_StaticEnum, TEXT("/Script/Engine"), TEXT("EMaterialShadingModel"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EMaterialShadingModel_CRC() { return 4291039179U; }
	UEnum* Z_Construct_UEnum_Engine_EMaterialShadingModel()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EMaterialShadingModel"), 0, Get_Z_Construct_UEnum_Engine_EMaterialShadingModel_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "MSM_Unlit", (int64)MSM_Unlit },
				{ "MSM_DefaultLit", (int64)MSM_DefaultLit },
				{ "MSM_Subsurface", (int64)MSM_Subsurface },
				{ "MSM_PreintegratedSkin", (int64)MSM_PreintegratedSkin },
				{ "MSM_ClearCoat", (int64)MSM_ClearCoat },
				{ "MSM_SubsurfaceProfile", (int64)MSM_SubsurfaceProfile },
				{ "MSM_TwoSidedFoliage", (int64)MSM_TwoSidedFoliage },
				{ "MSM_Hair", (int64)MSM_Hair },
				{ "MSM_Cloth", (int64)MSM_Cloth },
				{ "MSM_Eye", (int64)MSM_Eye },
				{ "MSM_MAX", (int64)MSM_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "MSM_ClearCoat.DisplayName", "Clear Coat" },
				{ "MSM_Cloth.DisplayName", "Cloth" },
				{ "MSM_DefaultLit.DisplayName", "Default Lit" },
				{ "MSM_Eye.DisplayName", "Eye" },
				{ "MSM_Hair.DisplayName", "Hair" },
				{ "MSM_PreintegratedSkin.DisplayName", "Preintegrated Skin" },
				{ "MSM_Subsurface.DisplayName", "Subsurface" },
				{ "MSM_SubsurfaceProfile.DisplayName", "Subsurface Profile" },
				{ "MSM_TwoSidedFoliage.DisplayName", "Two Sided Foliage" },
				{ "MSM_Unlit.DisplayName", "Unlit" },
				{ "ToolTip", "Note: Check UMaterialInstance::Serialize if changed!" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EMaterialShadingModel",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EMaterialShadingModel",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EParticleCollisionMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EParticleCollisionMode, Z_Construct_UPackage__Script_Engine(), TEXT("EParticleCollisionMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EParticleCollisionMode(EParticleCollisionMode_StaticEnum, TEXT("/Script/Engine"), TEXT("EParticleCollisionMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EParticleCollisionMode_CRC() { return 883110922U; }
	UEnum* Z_Construct_UEnum_Engine_EParticleCollisionMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EParticleCollisionMode"), 0, Get_Z_Construct_UEnum_Engine_EParticleCollisionMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EParticleCollisionMode::SceneDepth", (int64)EParticleCollisionMode::SceneDepth },
				{ "EParticleCollisionMode::DistanceField", (int64)EParticleCollisionMode::DistanceField },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "DistanceField.DisplayName", "Distance Field" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SceneDepth.DisplayName", "Scene Depth" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EParticleCollisionMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EParticleCollisionMode::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETrailWidthMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETrailWidthMode, Z_Construct_UPackage__Script_Engine(), TEXT("ETrailWidthMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETrailWidthMode(ETrailWidthMode_StaticEnum, TEXT("/Script/Engine"), TEXT("ETrailWidthMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETrailWidthMode_CRC() { return 3979021947U; }
	UEnum* Z_Construct_UEnum_Engine_ETrailWidthMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETrailWidthMode"), 0, Get_Z_Construct_UEnum_Engine_ETrailWidthMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ETrailWidthMode_FromCentre", (int64)ETrailWidthMode_FromCentre },
				{ "ETrailWidthMode_FromFirst", (int64)ETrailWidthMode_FromFirst },
				{ "ETrailWidthMode_FromSecond", (int64)ETrailWidthMode_FromSecond },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ETrailWidthMode_FromCentre.DisplayName", "From Centre" },
				{ "ETrailWidthMode_FromFirst.DisplayName", "From First Socket" },
				{ "ETrailWidthMode_FromSecond.DisplayName", "From Second Socket" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Controls the way that the width scale property affects animation trails." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETrailWidthMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ETrailWidthMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EGBufferFormat_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EGBufferFormat, Z_Construct_UPackage__Script_Engine(), TEXT("EGBufferFormat"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGBufferFormat(EGBufferFormat_StaticEnum, TEXT("/Script/Engine"), TEXT("EGBufferFormat"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EGBufferFormat_CRC() { return 405683047U; }
	UEnum* Z_Construct_UEnum_Engine_EGBufferFormat()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGBufferFormat"), 0, Get_Z_Construct_UEnum_Engine_EGBufferFormat_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EGBufferFormat::Force8BitsPerChannel", (int64)EGBufferFormat::Force8BitsPerChannel },
				{ "EGBufferFormat::Default", (int64)EGBufferFormat::Default },
				{ "EGBufferFormat::HighPrecisionNormals", (int64)EGBufferFormat::HighPrecisionNormals },
				{ "EGBufferFormat::Force16BitsPerChannel", (int64)EGBufferFormat::Force16BitsPerChannel },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "Default.ToolTip", "See GBuffer allocation function for layout details." },
				{ "Force16BitsPerChannel.DisplayName", "Force 16 Bits Per Channel" },
				{ "Force16BitsPerChannel.ToolTip", "Forces all GBuffers to 16 bits per channel. Intended as profiling for best quality." },
				{ "Force8BitsPerChannel.DisplayName", "Force 8 Bits Per Channel" },
				{ "Force8BitsPerChannel.ToolTip", "Forces all GBuffers to 8 bits per channel. Intended as profiling for best performance." },
				{ "HighPrecisionNormals.ToolTip", "Same as Default except normals are encoded at 16 bits per channel." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "* Enumerates available GBufferFormats.\n// When this enum is updated please update CVarGBufferFormat comments" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EGBufferFormat",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EGBufferFormat::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ESceneCaptureCompositeMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ESceneCaptureCompositeMode, Z_Construct_UPackage__Script_Engine(), TEXT("ESceneCaptureCompositeMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESceneCaptureCompositeMode(ESceneCaptureCompositeMode_StaticEnum, TEXT("/Script/Engine"), TEXT("ESceneCaptureCompositeMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ESceneCaptureCompositeMode_CRC() { return 3476114901U; }
	UEnum* Z_Construct_UEnum_Engine_ESceneCaptureCompositeMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESceneCaptureCompositeMode"), 0, Get_Z_Construct_UEnum_Engine_ESceneCaptureCompositeMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SCCM_Overwrite", (int64)SCCM_Overwrite },
				{ "SCCM_Additive", (int64)SCCM_Additive },
				{ "SCCM_Composite", (int64)SCCM_Composite },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SCCM_Additive.DisplayName", "Additive" },
				{ "SCCM_Composite.DisplayName", "Composite" },
				{ "SCCM_Overwrite.DisplayName", "Overwrite" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ESceneCaptureCompositeMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ESceneCaptureCompositeMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ESceneCaptureSource_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ESceneCaptureSource, Z_Construct_UPackage__Script_Engine(), TEXT("ESceneCaptureSource"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESceneCaptureSource(ESceneCaptureSource_StaticEnum, TEXT("/Script/Engine"), TEXT("ESceneCaptureSource"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ESceneCaptureSource_CRC() { return 2556973623U; }
	UEnum* Z_Construct_UEnum_Engine_ESceneCaptureSource()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESceneCaptureSource"), 0, Get_Z_Construct_UEnum_Engine_ESceneCaptureSource_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SCS_SceneColorHDR", (int64)SCS_SceneColorHDR },
				{ "SCS_SceneColorHDRNoAlpha", (int64)SCS_SceneColorHDRNoAlpha },
				{ "SCS_FinalColorLDR", (int64)SCS_FinalColorLDR },
				{ "SCS_SceneColorSceneDepth", (int64)SCS_SceneColorSceneDepth },
				{ "SCS_SceneDepth", (int64)SCS_SceneDepth },
				{ "SCS_DeviceDepth", (int64)SCS_DeviceDepth },
				{ "SCS_Normal", (int64)SCS_Normal },
				{ "SCS_BaseColor", (int64)SCS_BaseColor },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SCS_BaseColor.DisplayName", "BaseColor in RGB (Deferred Renderer only)" },
				{ "SCS_DeviceDepth.DisplayName", "DeviceDepth in RGB" },
				{ "SCS_FinalColorLDR.DisplayName", "Final Color (LDR) in RGB" },
				{ "SCS_Normal.DisplayName", "Normal in RGB (Deferred Renderer only)" },
				{ "SCS_SceneColorHDR.DisplayName", "SceneColor (HDR) in RGB, Inv Opacity in A" },
				{ "SCS_SceneColorHDRNoAlpha.DisplayName", "SceneColor (HDR) in RGB, 0 in A" },
				{ "SCS_SceneColorSceneDepth.DisplayName", "SceneColor (HDR) in RGB, SceneDepth in A" },
				{ "SCS_SceneDepth.DisplayName", "SceneDepth in R" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ESceneCaptureSource",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ESceneCaptureSource",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETranslucentSortPolicy_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETranslucentSortPolicy, Z_Construct_UPackage__Script_Engine(), TEXT("ETranslucentSortPolicy"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETranslucentSortPolicy(ETranslucentSortPolicy_StaticEnum, TEXT("/Script/Engine"), TEXT("ETranslucentSortPolicy"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETranslucentSortPolicy_CRC() { return 279115955U; }
	UEnum* Z_Construct_UEnum_Engine_ETranslucentSortPolicy()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETranslucentSortPolicy"), 0, Get_Z_Construct_UEnum_Engine_ETranslucentSortPolicy_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ETranslucentSortPolicy::SortByDistance", (int64)ETranslucentSortPolicy::SortByDistance },
				{ "ETranslucentSortPolicy::SortByProjectedZ", (int64)ETranslucentSortPolicy::SortByProjectedZ },
				{ "ETranslucentSortPolicy::SortAlongAxis", (int64)ETranslucentSortPolicy::SortAlongAxis },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SortAlongAxis.ToolTip", "Sort based on the projection onto a fixed axis. (Best for 2D games.)" },
				{ "SortByDistance.ToolTip", "Sort based on distance from camera centerpoint to bounding sphere centerpoint. (Default, best for 3D games.)" },
				{ "SortByProjectedZ.ToolTip", "Sort based on the post-projection Z distance to the camera." },
				{ "ToolTip", "Enumerates available options for the translucency sort policy." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETranslucentSortPolicy",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"ETranslucentSortPolicy::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ERefractionMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ERefractionMode, Z_Construct_UPackage__Script_Engine(), TEXT("ERefractionMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ERefractionMode(ERefractionMode_StaticEnum, TEXT("/Script/Engine"), TEXT("ERefractionMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ERefractionMode_CRC() { return 3581082550U; }
	UEnum* Z_Construct_UEnum_Engine_ERefractionMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ERefractionMode"), 0, Get_Z_Construct_UEnum_Engine_ERefractionMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "RM_IndexOfRefraction", (int64)RM_IndexOfRefraction },
				{ "RM_PixelNormalOffset", (int64)RM_PixelNormalOffset },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "RM_IndexOfRefraction.DisplayName", "Index Of Refraction" },
				{ "RM_IndexOfRefraction.ToolTip", "Refraction is computed based on the camera vector entering a medium whose index of refraction is defined by the Refraction material input.\nThe new medium's surface is defined by the material's normal.  With this mode, a flat plane seen from the side will have a constant refraction offset.\nThis is a physical model of refraction but causes reading outside the scene color texture so is a poor fit for large refractive surfaces like water." },
				{ "RM_PixelNormalOffset.DisplayName", "Pixel Normal Offset" },
				{ "RM_PixelNormalOffset.ToolTip", "The refraction offset into Scene Color is computed based on the difference between the per-pixel normal and the per-vertex normal.\nWith this mode, a material whose normal is the default (0, 0, 1) will never cause any refraction.  This mode is only valid with tangent space normals.\nThe refraction material input scales the offset, although a value of 1.0 maps to no refraction, and a value of 2 maps to a scale of 1.0 on the offset.\nThis is a non-physical model of refraction but is useful on large refractive surfaces like water, since offsets have to stay small to avoid reading outside scene color." },
				{ "ToolTip", "Determines how the refraction offset should be computed for the material." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ERefractionMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ERefractionMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ETranslucencyLightingMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ETranslucencyLightingMode, Z_Construct_UPackage__Script_Engine(), TEXT("ETranslucencyLightingMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ETranslucencyLightingMode(ETranslucencyLightingMode_StaticEnum, TEXT("/Script/Engine"), TEXT("ETranslucencyLightingMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ETranslucencyLightingMode_CRC() { return 3088766944U; }
	UEnum* Z_Construct_UEnum_Engine_ETranslucencyLightingMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ETranslucencyLightingMode"), 0, Get_Z_Construct_UEnum_Engine_ETranslucencyLightingMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "TLM_VolumetricNonDirectional", (int64)TLM_VolumetricNonDirectional },
				{ "TLM_VolumetricDirectional", (int64)TLM_VolumetricDirectional },
				{ "TLM_VolumetricPerVertexNonDirectional", (int64)TLM_VolumetricPerVertexNonDirectional },
				{ "TLM_VolumetricPerVertexDirectional", (int64)TLM_VolumetricPerVertexDirectional },
				{ "TLM_Surface", (int64)TLM_Surface },
				{ "TLM_SurfacePerPixelLighting", (int64)TLM_SurfacePerPixelLighting },
				{ "TLM_MAX", (int64)TLM_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "TLM_Surface.DisplayName", "Surface TranslucencyVolume" },
				{ "TLM_Surface.ToolTip", "Lighting will be calculated for a surface. The light in accumulated in a volume so the result is blurry,\nlimited distance but the per pixel cost is very low. Use this on translucent surfaces like glass and water.\nOnly diffuse lighting is supported." },
				{ "TLM_SurfacePerPixelLighting.DisplayName", "Surface ForwardShading" },
				{ "TLM_SurfacePerPixelLighting.ToolTip", "Lighting will be calculated for a surface. Use this on translucent surfaces like glass and water.\nThis is implemented with forward shading so specular highlights from local lights are supported, however many deferred-only features are not.\nThis is the most expensive translucency lighting method as each light's contribution is computed per-pixel." },
				{ "TLM_VolumetricDirectional.DisplayName", "Volumetric Directional" },
				{ "TLM_VolumetricDirectional.ToolTip", "Lighting will be calculated for a volume, with directionality so that the normal of the material is taken into account.\nNote that the default particle tangent space is facing the camera, so enable bGenerateSphericalParticleNormals to get a more useful tangent space." },
				{ "TLM_VolumetricNonDirectional.DisplayName", "Volumetric NonDirectional" },
				{ "TLM_VolumetricNonDirectional.ToolTip", "Lighting will be calculated for a volume, without directionality.  Use this on particle effects like smoke and dust.\nThis is the cheapest per-pixel lighting method, however the material normal is not taken into account." },
				{ "TLM_VolumetricPerVertexDirectional.DisplayName", "Volumetric PerVertex Directional" },
				{ "TLM_VolumetricPerVertexDirectional.ToolTip", "Same as Volumetric Directional, but lighting is only evaluated at vertices so the pixel shader cost is significantly less.\nNote that lighting still comes from a volume texture, so it is limited in range.  Directional lights become unshadowed in the distance." },
				{ "TLM_VolumetricPerVertexNonDirectional.DisplayName", "Volumetric PerVertex NonDirectional" },
				{ "TLM_VolumetricPerVertexNonDirectional.ToolTip", "Same as Volumetric Non Directional, but lighting is only evaluated at vertices so the pixel shader cost is significantly less.\nNote that lighting still comes from a volume texture, so it is limited in range.  Directional lights become unshadowed in the distance." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ETranslucencyLightingMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ETranslucencyLightingMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ESamplerSourceMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ESamplerSourceMode, Z_Construct_UPackage__Script_Engine(), TEXT("ESamplerSourceMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESamplerSourceMode(ESamplerSourceMode_StaticEnum, TEXT("/Script/Engine"), TEXT("ESamplerSourceMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ESamplerSourceMode_CRC() { return 2733906952U; }
	UEnum* Z_Construct_UEnum_Engine_ESamplerSourceMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESamplerSourceMode"), 0, Get_Z_Construct_UEnum_Engine_ESamplerSourceMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SSM_FromTextureAsset", (int64)SSM_FromTextureAsset },
				{ "SSM_Wrap_WorldGroupSettings", (int64)SSM_Wrap_WorldGroupSettings },
				{ "SSM_Clamp_WorldGroupSettings", (int64)SSM_Clamp_WorldGroupSettings },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SSM_Clamp_WorldGroupSettings.DisplayName", "Shared: Clamp" },
				{ "SSM_Clamp_WorldGroupSettings.ToolTip", "Shared sampler source that does not consume a sampler slot.  Uses clamp addressing and gets filter mode from the world texture group." },
				{ "SSM_FromTextureAsset.DisplayName", "From texture asset" },
				{ "SSM_FromTextureAsset.ToolTip", "Get the sampler from the texture.  Every unique texture will consume a sampler slot, which are limited in number." },
				{ "SSM_Wrap_WorldGroupSettings.DisplayName", "Shared: Wrap" },
				{ "SSM_Wrap_WorldGroupSettings.ToolTip", "Shared sampler source that does not consume a sampler slot.  Uses wrap addressing and gets filter mode from the world texture group." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ESamplerSourceMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ESamplerSourceMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EBlendMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EBlendMode, Z_Construct_UPackage__Script_Engine(), TEXT("EBlendMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EBlendMode(EBlendMode_StaticEnum, TEXT("/Script/Engine"), TEXT("EBlendMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EBlendMode_CRC() { return 1217002510U; }
	UEnum* Z_Construct_UEnum_Engine_EBlendMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EBlendMode"), 0, Get_Z_Construct_UEnum_Engine_EBlendMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "BLEND_Opaque", (int64)BLEND_Opaque },
				{ "BLEND_Masked", (int64)BLEND_Masked },
				{ "BLEND_Translucent", (int64)BLEND_Translucent },
				{ "BLEND_Additive", (int64)BLEND_Additive },
				{ "BLEND_Modulate", (int64)BLEND_Modulate },
				{ "BLEND_AlphaComposite", (int64)BLEND_AlphaComposite },
				{ "BLEND_MAX", (int64)BLEND_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "BLEND_Additive.DisplayName", "Additive" },
				{ "BLEND_AlphaComposite.DisplayName", "AlphaComposite (Premultiplied Alpha)" },
				{ "BLEND_Masked.DisplayName", "Masked" },
				{ "BLEND_Modulate.DisplayName", "Modulate" },
				{ "BLEND_Opaque.DisplayName", "Opaque" },
				{ "BLEND_Translucent.DisplayName", "Translucent" },
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Note: This is mirrored in Lightmass, be sure to update the blend mode structure and logic there if this changes. // Note: Check UMaterialInstance::Serialize if changed!!" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EBlendMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EBlendMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EOcclusionCombineMode_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EOcclusionCombineMode, Z_Construct_UPackage__Script_Engine(), TEXT("EOcclusionCombineMode"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EOcclusionCombineMode(EOcclusionCombineMode_StaticEnum, TEXT("/Script/Engine"), TEXT("EOcclusionCombineMode"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EOcclusionCombineMode_CRC() { return 1607540940U; }
	UEnum* Z_Construct_UEnum_Engine_EOcclusionCombineMode()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EOcclusionCombineMode"), 0, Get_Z_Construct_UEnum_Engine_EOcclusionCombineMode_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "OCM_Minimum", (int64)OCM_Minimum },
				{ "OCM_Multiply", (int64)OCM_Multiply },
				{ "OCM_MAX", (int64)OCM_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "OCM_Minimum.ToolTip", "Take the minimum occlusion value.  This is effective for avoiding over-occlusion from multiple methods, but can result in indoors looking too flat." },
				{ "OCM_Multiply.ToolTip", "Multiply together occlusion values from Distance Field Ambient Occlusion and Screen Space Ambient Occlusion.\nThis gives a good sense of depth everywhere, but can cause over-occlusion.\nSSAO should be tweaked to be less strong compared to Minimum." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EOcclusionCombineMode",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EOcclusionCombineMode",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EIndirectLightingCacheQuality_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality, Z_Construct_UPackage__Script_Engine(), TEXT("EIndirectLightingCacheQuality"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EIndirectLightingCacheQuality(EIndirectLightingCacheQuality_StaticEnum, TEXT("/Script/Engine"), TEXT("EIndirectLightingCacheQuality"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality_CRC() { return 1613118310U; }
	UEnum* Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EIndirectLightingCacheQuality"), 0, Get_Z_Construct_UEnum_Engine_EIndirectLightingCacheQuality_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "ILCQ_Off", (int64)ILCQ_Off },
				{ "ILCQ_Point", (int64)ILCQ_Point },
				{ "ILCQ_Volume", (int64)ILCQ_Volume },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ILCQ_Off.ToolTip", "The indirect lighting cache will be disabled for this object, so no GI from stationary lights on movable objects." },
				{ "ILCQ_Point.ToolTip", "A single indirect lighting sample computed at the bounds origin will be interpolated which fades over time to newer results." },
				{ "ILCQ_Volume.ToolTip", "The object will get a 5x5x5 stable volume of interpolated indirect lighting, which allows gradients of lighting intensity across the receiving object." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EIndirectLightingCacheQuality",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EIndirectLightingCacheQuality",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* ESceneDepthPriorityGroup_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup, Z_Construct_UPackage__Script_Engine(), TEXT("ESceneDepthPriorityGroup"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESceneDepthPriorityGroup(ESceneDepthPriorityGroup_StaticEnum, TEXT("/Script/Engine"), TEXT("ESceneDepthPriorityGroup"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup_CRC() { return 3106811729U; }
	UEnum* Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESceneDepthPriorityGroup"), 0, Get_Z_Construct_UEnum_Engine_ESceneDepthPriorityGroup_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "SDPG_World", (int64)SDPG_World },
				{ "SDPG_Foreground", (int64)SDPG_Foreground },
				{ "SDPG_MAX", (int64)SDPG_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SDPG_Foreground.ToolTip", "Foreground scene DPG." },
				{ "SDPG_World.ToolTip", "World scene DPG." },
				{ "ToolTip", "A priority for sorting scene elements by depth.\nElements with higher priority occlude elements with lower priority, disregarding distance." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"ESceneDepthPriorityGroup",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"ESceneDepthPriorityGroup",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EAttachLocation_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EAttachLocation, Z_Construct_UPackage__Script_Engine(), TEXT("EAttachLocation"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAttachLocation(EAttachLocation_StaticEnum, TEXT("/Script/Engine"), TEXT("EAttachLocation"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EAttachLocation_CRC() { return 695419830U; }
	UEnum* Z_Construct_UEnum_Engine_EAttachLocation()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAttachLocation"), 0, Get_Z_Construct_UEnum_Engine_EAttachLocation_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EAttachLocation::KeepRelativeOffset", (int64)EAttachLocation::KeepRelativeOffset },
				{ "EAttachLocation::KeepWorldPosition", (int64)EAttachLocation::KeepWorldPosition },
				{ "EAttachLocation::SnapToTarget", (int64)EAttachLocation::SnapToTarget },
				{ "EAttachLocation::SnapToTargetIncludingScale", (int64)EAttachLocation::SnapToTargetIncludingScale },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "KeepRelativeOffset.ToolTip", "Keeps current relative transform as the relative transform to the new parent." },
				{ "KeepWorldPosition.ToolTip", "Automatically calculates the relative transform such that the attached component maintains the same world transform." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SnapToTarget.DisplayName", "Snap to Target, Keep World Scale" },
				{ "SnapToTarget.ToolTip", "Snaps location and rotation to the attach point. Calculates the relative scale so that the final world scale of the component remains the same." },
				{ "SnapToTargetIncludingScale.DisplayName", "Snap to Target, Including Scale" },
				{ "SnapToTargetIncludingScale.ToolTip", "Snaps entire transform to target, including scale." },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAttachLocation",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Namespaced,
				"EAttachLocation::Type",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EDetachmentRule_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EDetachmentRule, Z_Construct_UPackage__Script_Engine(), TEXT("EDetachmentRule"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EDetachmentRule(EDetachmentRule_StaticEnum, TEXT("/Script/Engine"), TEXT("EDetachmentRule"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EDetachmentRule_CRC() { return 3682074671U; }
	UEnum* Z_Construct_UEnum_Engine_EDetachmentRule()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EDetachmentRule"), 0, Get_Z_Construct_UEnum_Engine_EDetachmentRule_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EDetachmentRule::KeepRelative", (int64)EDetachmentRule::KeepRelative },
				{ "EDetachmentRule::KeepWorld", (int64)EDetachmentRule::KeepWorld },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "KeepRelative.ToolTip", "Keeps current relative transform." },
				{ "KeepWorld.ToolTip", "Automatically calculates the relative transform such that the detached component maintains the same world transform." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Rules for detaching components - needs to be kept synced to EAttachmentRule" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EDetachmentRule",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EDetachmentRule",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EAttachmentRule_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EAttachmentRule, Z_Construct_UPackage__Script_Engine(), TEXT("EAttachmentRule"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAttachmentRule(EAttachmentRule_StaticEnum, TEXT("/Script/Engine"), TEXT("EAttachmentRule"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EAttachmentRule_CRC() { return 66091881U; }
	UEnum* Z_Construct_UEnum_Engine_EAttachmentRule()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAttachmentRule"), 0, Get_Z_Construct_UEnum_Engine_EAttachmentRule_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "EAttachmentRule::KeepRelative", (int64)EAttachmentRule::KeepRelative },
				{ "EAttachmentRule::KeepWorld", (int64)EAttachmentRule::KeepWorld },
				{ "EAttachmentRule::SnapToTarget", (int64)EAttachmentRule::SnapToTarget },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "KeepRelative.ToolTip", "Keeps current relative transform as the relative transform to the new parent." },
				{ "KeepWorld.ToolTip", "Automatically calculates the relative transform such that the attached component maintains the same world transform." },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "SnapToTarget.ToolTip", "Snaps transform to the attach point" },
				{ "ToolTip", "Rules for attaching components - needs to be kept synced to EDetachmentRule" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAttachmentRule",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::EnumClass,
				"EAttachmentRule",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EActorMetricsType_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EActorMetricsType, Z_Construct_UPackage__Script_Engine(), TEXT("EActorMetricsType"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EActorMetricsType(EActorMetricsType_StaticEnum, TEXT("/Script/Engine"), TEXT("EActorMetricsType"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EActorMetricsType_CRC() { return 1274970226U; }
	UEnum* Z_Construct_UEnum_Engine_EActorMetricsType()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EActorMetricsType"), 0, Get_Z_Construct_UEnum_Engine_EActorMetricsType_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "METRICS_VERTS", (int64)METRICS_VERTS },
				{ "METRICS_TRIS", (int64)METRICS_TRIS },
				{ "METRICS_SECTIONS", (int64)METRICS_SECTIONS },
				{ "METRICS_MAX", (int64)METRICS_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The type of metric we want about the actor *" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EActorMetricsType",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EActorMetricsType",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
	static UEnum* EAspectRatioAxisConstraint_StaticEnum()
	{
		static UEnum* Singleton = nullptr;
		if (!Singleton)
		{
			Singleton = GetStaticEnum(Z_Construct_UEnum_Engine_EAspectRatioAxisConstraint, Z_Construct_UPackage__Script_Engine(), TEXT("EAspectRatioAxisConstraint"));
		}
		return Singleton;
	}
	static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAspectRatioAxisConstraint(EAspectRatioAxisConstraint_StaticEnum, TEXT("/Script/Engine"), TEXT("EAspectRatioAxisConstraint"), false, nullptr, nullptr);
	uint32 Get_Z_Construct_UEnum_Engine_EAspectRatioAxisConstraint_CRC() { return 2518271758U; }
	UEnum* Z_Construct_UEnum_Engine_EAspectRatioAxisConstraint()
	{
#if WITH_HOT_RELOAD
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAspectRatioAxisConstraint"), 0, Get_Z_Construct_UEnum_Engine_EAspectRatioAxisConstraint_CRC(), false);
#else
		static UEnum* ReturnEnum = nullptr;
#endif // WITH_HOT_RELOAD
		if (!ReturnEnum)
		{
			static const UE4CodeGen_Private::FEnumeratorParam Enumerators[] = {
				{ "AspectRatio_MaintainYFOV", (int64)AspectRatio_MaintainYFOV },
				{ "AspectRatio_MaintainXFOV", (int64)AspectRatio_MaintainXFOV },
				{ "AspectRatio_MajorAxisFOV", (int64)AspectRatio_MajorAxisFOV },
				{ "AspectRatio_MAX", (int64)AspectRatio_MAX },
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {
				{ "AspectRatio_MaintainXFOV.DisplayName", "Maintain X-Axis FOV" },
				{ "AspectRatio_MaintainYFOV.DisplayName", "Maintain Y-Axis FOV" },
				{ "AspectRatio_MajorAxisFOV.DisplayName", "Maintain Major Axis FOV" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FEnumParams EnumParams = {
				(UObject*(*)())Z_Construct_UPackage__Script_Engine,
				UE4CodeGen_Private::EDynamicType::NotDynamic,
				"EAspectRatioAxisConstraint",
				RF_Public|RF_Transient|RF_MarkAsNative,
				nullptr,
				(uint8)UEnum::ECppForm::Regular,
				"EAspectRatioAxisConstraint",
				Enumerators,
				ARRAY_COUNT(Enumerators),
				METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams);
		}
		return ReturnEnum;
	}
class UScriptStruct* FUserActivity::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FUserActivity_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FUserActivity, Z_Construct_UPackage__Script_Engine(), TEXT("UserActivity"), sizeof(FUserActivity), Get_Z_Construct_UScriptStruct_FUserActivity_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FUserActivity(FUserActivity::StaticStruct, TEXT("/Script/Engine"), TEXT("UserActivity"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFUserActivity
{
	FScriptStruct_Engine_StaticRegisterNativesFUserActivity()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("UserActivity")),new UScriptStruct::TCppStructOps<FUserActivity>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFUserActivity;
	UScriptStruct* Z_Construct_UScriptStruct_FUserActivity()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FUserActivity_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("UserActivity"), sizeof(FUserActivity), Get_Z_Construct_UScriptStruct_FUserActivity_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The description of a user activity" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FUserActivity>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ActionName_MetaData[] = {
				{ "Category", "Activity" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Describes the user's activity" },
			};
#endif
			static const UE4CodeGen_Private::FStrPropertyParams NewProp_ActionName = { UE4CodeGen_Private::EPropertyClass::Str, "ActionName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, STRUCT_OFFSET(FUserActivity, ActionName), METADATA_PARAMS(NewProp_ActionName_MetaData, ARRAY_COUNT(NewProp_ActionName_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ActionName,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"UserActivity",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FUserActivity),
				alignof(FUserActivity),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FUserActivity_CRC() { return 4209259041U; }
class UScriptStruct* FCanvasUVTri::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FCanvasUVTri_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FCanvasUVTri, Z_Construct_UPackage__Script_Engine(), TEXT("CanvasUVTri"), sizeof(FCanvasUVTri), Get_Z_Construct_UScriptStruct_FCanvasUVTri_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FCanvasUVTri(FCanvasUVTri::StaticStruct, TEXT("/Script/Engine"), TEXT("CanvasUVTri"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFCanvasUVTri
{
	FScriptStruct_Engine_StaticRegisterNativesFCanvasUVTri()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("CanvasUVTri")),new UScriptStruct::TCppStructOps<FCanvasUVTri>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFCanvasUVTri;
	UScriptStruct* Z_Construct_UScriptStruct_FCanvasUVTri()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FCanvasUVTri_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("CanvasUVTri"), sizeof(FCanvasUVTri), Get_Z_Construct_UScriptStruct_FCanvasUVTri_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Simple 2d triangle with UVs" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FCanvasUVTri>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V2_Color_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Color of third vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V2_Color = { UE4CodeGen_Private::EPropertyClass::Struct, "V2_Color", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V2_Color), Z_Construct_UScriptStruct_FLinearColor, METADATA_PARAMS(NewProp_V2_Color_MetaData, ARRAY_COUNT(NewProp_V2_Color_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V2_UV_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "UV of third vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V2_UV = { UE4CodeGen_Private::EPropertyClass::Struct, "V2_UV", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V2_UV), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_V2_UV_MetaData, ARRAY_COUNT(NewProp_V2_UV_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V2_Pos_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Position of third vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V2_Pos = { UE4CodeGen_Private::EPropertyClass::Struct, "V2_Pos", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V2_Pos), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_V2_Pos_MetaData, ARRAY_COUNT(NewProp_V2_Pos_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V1_Color_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Color of second vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V1_Color = { UE4CodeGen_Private::EPropertyClass::Struct, "V1_Color", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V1_Color), Z_Construct_UScriptStruct_FLinearColor, METADATA_PARAMS(NewProp_V1_Color_MetaData, ARRAY_COUNT(NewProp_V1_Color_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V1_UV_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "UV of second vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V1_UV = { UE4CodeGen_Private::EPropertyClass::Struct, "V1_UV", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V1_UV), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_V1_UV_MetaData, ARRAY_COUNT(NewProp_V1_UV_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V1_Pos_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Position of second vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V1_Pos = { UE4CodeGen_Private::EPropertyClass::Struct, "V1_Pos", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V1_Pos), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_V1_Pos_MetaData, ARRAY_COUNT(NewProp_V1_Pos_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V0_Color_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Color of first vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V0_Color = { UE4CodeGen_Private::EPropertyClass::Struct, "V0_Color", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V0_Color), Z_Construct_UScriptStruct_FLinearColor, METADATA_PARAMS(NewProp_V0_Color_MetaData, ARRAY_COUNT(NewProp_V0_Color_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V0_UV_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "UV of first vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V0_UV = { UE4CodeGen_Private::EPropertyClass::Struct, "V0_UV", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V0_UV), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_V0_UV_MetaData, ARRAY_COUNT(NewProp_V0_UV_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_V0_Pos_MetaData[] = {
				{ "Category", "CanvasUVTri" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Position of first vertex" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_V0_Pos = { UE4CodeGen_Private::EPropertyClass::Struct, "V0_Pos", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCanvasUVTri, V0_Pos), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_V0_Pos_MetaData, ARRAY_COUNT(NewProp_V0_Pos_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V2_Color,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V2_UV,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V2_Pos,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V1_Color,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V1_UV,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V1_Pos,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V0_Color,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V0_UV,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_V0_Pos,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"CanvasUVTri",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FCanvasUVTri),
				alignof(FCanvasUVTri),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FCanvasUVTri_CRC() { return 1137802557U; }
class UScriptStruct* FFontRenderInfo::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FFontRenderInfo_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FFontRenderInfo, Z_Construct_UPackage__Script_Engine(), TEXT("FontRenderInfo"), sizeof(FFontRenderInfo), Get_Z_Construct_UScriptStruct_FFontRenderInfo_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FFontRenderInfo(FFontRenderInfo::StaticStruct, TEXT("/Script/Engine"), TEXT("FontRenderInfo"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFFontRenderInfo
{
	FScriptStruct_Engine_StaticRegisterNativesFFontRenderInfo()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("FontRenderInfo")),new UScriptStruct::TCppStructOps<FFontRenderInfo>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFFontRenderInfo;
	UScriptStruct* Z_Construct_UScriptStruct_FFontRenderInfo()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FFontRenderInfo_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FontRenderInfo"), sizeof(FFontRenderInfo), Get_Z_Construct_UScriptStruct_FFontRenderInfo_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "information used in font rendering" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FFontRenderInfo>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GlowInfo_MetaData[] = {
				{ "Category", "FontInfo" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "depth field glow parameters (only usable if font was imported with a depth field)" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_GlowInfo = { UE4CodeGen_Private::EPropertyClass::Struct, "GlowInfo", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, STRUCT_OFFSET(FFontRenderInfo, GlowInfo), Z_Construct_UScriptStruct_FDepthFieldGlowInfo, METADATA_PARAMS(NewProp_GlowInfo_MetaData, ARRAY_COUNT(NewProp_GlowInfo_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bEnableShadow_MetaData[] = {
				{ "Category", "FontInfo" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "whether to turn on shadowing" },
			};
#endif
			auto NewProp_bEnableShadow_SetBit = [](void* Obj){ ((FFontRenderInfo*)Obj)->bEnableShadow = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bEnableShadow = { UE4CodeGen_Private::EPropertyClass::Bool, "bEnableShadow", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FFontRenderInfo), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bEnableShadow_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bEnableShadow_MetaData, ARRAY_COUNT(NewProp_bEnableShadow_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bClipText_MetaData[] = {
				{ "Category", "FontInfo" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "whether to clip text" },
			};
#endif
			auto NewProp_bClipText_SetBit = [](void* Obj){ ((FFontRenderInfo*)Obj)->bClipText = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bClipText = { UE4CodeGen_Private::EPropertyClass::Bool, "bClipText", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FFontRenderInfo), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bClipText_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bClipText_MetaData, ARRAY_COUNT(NewProp_bClipText_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GlowInfo,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bEnableShadow,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bClipText,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"FontRenderInfo",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FFontRenderInfo),
				alignof(FFontRenderInfo),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFontRenderInfo_CRC() { return 2838262935U; }
class UScriptStruct* FDepthFieldGlowInfo::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FDepthFieldGlowInfo_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FDepthFieldGlowInfo, Z_Construct_UPackage__Script_Engine(), TEXT("DepthFieldGlowInfo"), sizeof(FDepthFieldGlowInfo), Get_Z_Construct_UScriptStruct_FDepthFieldGlowInfo_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FDepthFieldGlowInfo(FDepthFieldGlowInfo::StaticStruct, TEXT("/Script/Engine"), TEXT("DepthFieldGlowInfo"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFDepthFieldGlowInfo
{
	FScriptStruct_Engine_StaticRegisterNativesFDepthFieldGlowInfo()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("DepthFieldGlowInfo")),new UScriptStruct::TCppStructOps<FDepthFieldGlowInfo>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFDepthFieldGlowInfo;
	UScriptStruct* Z_Construct_UScriptStruct_FDepthFieldGlowInfo()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FDepthFieldGlowInfo_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("DepthFieldGlowInfo"), sizeof(FDepthFieldGlowInfo), Get_Z_Construct_UScriptStruct_FDepthFieldGlowInfo_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "info for glow when using depth field rendering" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FDepthFieldGlowInfo>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GlowInnerRadius_MetaData[] = {
				{ "Category", "Glow" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "if bEnableGlow, outline glow inner radius (0 to 1, 0.5 is edge of character silhouette)\nglow influence will be 1 at GlowInnerRadius.X and 0 at GlowInnerRadius.Y" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_GlowInnerRadius = { UE4CodeGen_Private::EPropertyClass::Struct, "GlowInnerRadius", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, STRUCT_OFFSET(FDepthFieldGlowInfo, GlowInnerRadius), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_GlowInnerRadius_MetaData, ARRAY_COUNT(NewProp_GlowInnerRadius_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GlowOuterRadius_MetaData[] = {
				{ "Category", "Glow" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "if bEnableGlow, outline glow outer radius (0 to 1, 0.5 is edge of character silhouette)\nglow influence will be 0 at GlowOuterRadius.X and 1 at GlowOuterRadius.Y" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_GlowOuterRadius = { UE4CodeGen_Private::EPropertyClass::Struct, "GlowOuterRadius", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, STRUCT_OFFSET(FDepthFieldGlowInfo, GlowOuterRadius), Z_Construct_UScriptStruct_FVector2D, METADATA_PARAMS(NewProp_GlowOuterRadius_MetaData, ARRAY_COUNT(NewProp_GlowOuterRadius_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GlowColor_MetaData[] = {
				{ "Category", "Glow" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "base color to use for the glow" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_GlowColor = { UE4CodeGen_Private::EPropertyClass::Struct, "GlowColor", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, STRUCT_OFFSET(FDepthFieldGlowInfo, GlowColor), Z_Construct_UScriptStruct_FLinearColor, METADATA_PARAMS(NewProp_GlowColor_MetaData, ARRAY_COUNT(NewProp_GlowColor_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bEnableGlow_MetaData[] = {
				{ "Category", "Glow" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "whether to turn on the outline glow (depth field fonts only)" },
			};
#endif
			auto NewProp_bEnableGlow_SetBit = [](void* Obj){ ((FDepthFieldGlowInfo*)Obj)->bEnableGlow = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bEnableGlow = { UE4CodeGen_Private::EPropertyClass::Bool, "bEnableGlow", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000004, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FDepthFieldGlowInfo), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bEnableGlow_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bEnableGlow_MetaData, ARRAY_COUNT(NewProp_bEnableGlow_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GlowInnerRadius,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GlowOuterRadius,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GlowColor,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bEnableGlow,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"DepthFieldGlowInfo",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FDepthFieldGlowInfo),
				alignof(FDepthFieldGlowInfo),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FDepthFieldGlowInfo_CRC() { return 3678430577U; }
class UScriptStruct* FDebugFloatHistory::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FDebugFloatHistory_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FDebugFloatHistory, Z_Construct_UPackage__Script_Engine(), TEXT("DebugFloatHistory"), sizeof(FDebugFloatHistory), Get_Z_Construct_UScriptStruct_FDebugFloatHistory_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FDebugFloatHistory(FDebugFloatHistory::StaticStruct, TEXT("/Script/Engine"), TEXT("DebugFloatHistory"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFDebugFloatHistory
{
	FScriptStruct_Engine_StaticRegisterNativesFDebugFloatHistory()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("DebugFloatHistory")),new UScriptStruct::TCppStructOps<FDebugFloatHistory>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFDebugFloatHistory;
	UScriptStruct* Z_Construct_UScriptStruct_FDebugFloatHistory()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FDebugFloatHistory_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("DebugFloatHistory"), sizeof(FDebugFloatHistory), Get_Z_Construct_UScriptStruct_FDebugFloatHistory_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Structure for recording float values and displaying them as an Histogram through DrawDebugFloatHistory." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FDebugFloatHistory>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bAutoAdjustMinMax_MetaData[] = {
				{ "Category", "DebugFloatHistory" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Auto adjust Min/Max as new values are recorded?" },
			};
#endif
			auto NewProp_bAutoAdjustMinMax_SetBit = [](void* Obj){ ((FDebugFloatHistory*)Obj)->bAutoAdjustMinMax = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bAutoAdjustMinMax = { UE4CodeGen_Private::EPropertyClass::Bool, "bAutoAdjustMinMax", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FDebugFloatHistory), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bAutoAdjustMinMax_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bAutoAdjustMinMax_MetaData, ARRAY_COUNT(NewProp_bAutoAdjustMinMax_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MaxValue_MetaData[] = {
				{ "Category", "DebugFloatHistory" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Max value to record." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_MaxValue = { UE4CodeGen_Private::EPropertyClass::Float, "MaxValue", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FDebugFloatHistory, MaxValue), METADATA_PARAMS(NewProp_MaxValue_MetaData, ARRAY_COUNT(NewProp_MaxValue_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MinValue_MetaData[] = {
				{ "Category", "DebugFloatHistory" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Min value to record." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_MinValue = { UE4CodeGen_Private::EPropertyClass::Float, "MinValue", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FDebugFloatHistory, MinValue), METADATA_PARAMS(NewProp_MinValue_MetaData, ARRAY_COUNT(NewProp_MinValue_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MaxSamples_MetaData[] = {
				{ "Category", "DebugFloatHistory" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Max Samples to record." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_MaxSamples = { UE4CodeGen_Private::EPropertyClass::Float, "MaxSamples", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FDebugFloatHistory, MaxSamples), METADATA_PARAMS(NewProp_MaxSamples_MetaData, ARRAY_COUNT(NewProp_MaxSamples_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Samples_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Samples" },
			};
#endif
			static const UE4CodeGen_Private::FArrayPropertyParams NewProp_Samples = { UE4CodeGen_Private::EPropertyClass::Array, "Samples", RF_Public|RF_Transient|RF_MarkAsNative, 0x0040000000002000, 1, nullptr, STRUCT_OFFSET(FDebugFloatHistory, Samples), METADATA_PARAMS(NewProp_Samples_MetaData, ARRAY_COUNT(NewProp_Samples_MetaData)) };
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Samples_Inner = { UE4CodeGen_Private::EPropertyClass::Float, "Samples", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, METADATA_PARAMS(nullptr, 0) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bAutoAdjustMinMax,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_MaxValue,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_MinValue,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_MaxSamples,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Samples,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Samples_Inner,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"DebugFloatHistory",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FDebugFloatHistory),
				alignof(FDebugFloatHistory),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FDebugFloatHistory_CRC() { return 1422021773U; }
class UScriptStruct* FRedirector::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRedirector_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRedirector, Z_Construct_UPackage__Script_Engine(), TEXT("Redirector"), sizeof(FRedirector), Get_Z_Construct_UScriptStruct_FRedirector_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRedirector(FRedirector::StaticStruct, TEXT("/Script/Engine"), TEXT("Redirector"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRedirector
{
	FScriptStruct_Engine_StaticRegisterNativesFRedirector()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("Redirector")),new UScriptStruct::TCppStructOps<FRedirector>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRedirector;
	UScriptStruct* Z_Construct_UScriptStruct_FRedirector()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRedirector_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Redirector"), sizeof(FRedirector), Get_Z_Construct_UScriptStruct_FRedirector_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "This is used for redirecting old name to new name\nWe use manually parsing array, but that makes harder to modify from property setting\nSo adding this USTRUCT to support it properly" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRedirector>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_NewName_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Types of objects that this physics objects will collide with." },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_NewName = { UE4CodeGen_Private::EPropertyClass::Name, "NewName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRedirector, NewName), METADATA_PARAMS(NewProp_NewName_MetaData, ARRAY_COUNT(NewProp_NewName_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_OldName_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_OldName = { UE4CodeGen_Private::EPropertyClass::Name, "OldName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRedirector, OldName), METADATA_PARAMS(NewProp_OldName_MetaData, ARRAY_COUNT(NewProp_OldName_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_NewName,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_OldName,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"Redirector",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FRedirector),
				alignof(FRedirector),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRedirector_CRC() { return 1885283182U; }
class UScriptStruct* FCollectionReference::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FCollectionReference_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FCollectionReference, Z_Construct_UPackage__Script_Engine(), TEXT("CollectionReference"), sizeof(FCollectionReference), Get_Z_Construct_UScriptStruct_FCollectionReference_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FCollectionReference(FCollectionReference::StaticStruct, TEXT("/Script/Engine"), TEXT("CollectionReference"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFCollectionReference
{
	FScriptStruct_Engine_StaticRegisterNativesFCollectionReference()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("CollectionReference")),new UScriptStruct::TCppStructOps<FCollectionReference>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFCollectionReference;
	UScriptStruct* Z_Construct_UScriptStruct_FCollectionReference()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FCollectionReference_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("CollectionReference"), sizeof(FCollectionReference), Get_Z_Construct_UScriptStruct_FCollectionReference_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Reference to an editor collection of assets. This allows an editor-only picker UI" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FCollectionReference>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_CollectionName_MetaData[] = {
				{ "Category", "CollectionReference" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Name of the collection" },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_CollectionName = { UE4CodeGen_Private::EPropertyClass::Name, "CollectionName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FCollectionReference, CollectionName), METADATA_PARAMS(NewProp_CollectionName_MetaData, ARRAY_COUNT(NewProp_CollectionName_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_CollectionName,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"CollectionReference",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FCollectionReference),
				alignof(FCollectionReference),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FCollectionReference_CRC() { return 1500305930U; }
class UScriptStruct* FDirectoryPath::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FDirectoryPath_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FDirectoryPath, Z_Construct_UPackage__Script_Engine(), TEXT("DirectoryPath"), sizeof(FDirectoryPath), Get_Z_Construct_UScriptStruct_FDirectoryPath_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FDirectoryPath(FDirectoryPath::StaticStruct, TEXT("/Script/Engine"), TEXT("DirectoryPath"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFDirectoryPath
{
	FScriptStruct_Engine_StaticRegisterNativesFDirectoryPath()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("DirectoryPath")),new UScriptStruct::TCppStructOps<FDirectoryPath>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFDirectoryPath;
	UScriptStruct* Z_Construct_UScriptStruct_FDirectoryPath()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FDirectoryPath_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("DirectoryPath"), sizeof(FDirectoryPath), Get_Z_Construct_UScriptStruct_FDirectoryPath_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Structure for directory paths that are displayed in the UI." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FDirectoryPath>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Path_MetaData[] = {
				{ "Category", "Path" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The path to the directory." },
			};
#endif
			static const UE4CodeGen_Private::FStrPropertyParams NewProp_Path = { UE4CodeGen_Private::EPropertyClass::Str, "Path", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FDirectoryPath, Path), METADATA_PARAMS(NewProp_Path_MetaData, ARRAY_COUNT(NewProp_Path_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Path,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"DirectoryPath",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FDirectoryPath),
				alignof(FDirectoryPath),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FDirectoryPath_CRC() { return 1446124433U; }
class UScriptStruct* FFilePath::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FFilePath_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FFilePath, Z_Construct_UPackage__Script_Engine(), TEXT("FilePath"), sizeof(FFilePath), Get_Z_Construct_UScriptStruct_FFilePath_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FFilePath(FFilePath::StaticStruct, TEXT("/Script/Engine"), TEXT("FilePath"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFFilePath
{
	FScriptStruct_Engine_StaticRegisterNativesFFilePath()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("FilePath")),new UScriptStruct::TCppStructOps<FFilePath>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFFilePath;
	UScriptStruct* Z_Construct_UScriptStruct_FFilePath()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FFilePath_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FilePath"), sizeof(FFilePath), Get_Z_Construct_UScriptStruct_FFilePath_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Structure for file paths that are displayed in the UI." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FFilePath>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_FilePath_MetaData[] = {
				{ "Category", "FilePath" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The path to the file." },
			};
#endif
			static const UE4CodeGen_Private::FStrPropertyParams NewProp_FilePath = { UE4CodeGen_Private::EPropertyClass::Str, "FilePath", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FFilePath, FilePath), METADATA_PARAMS(NewProp_FilePath_MetaData, ARRAY_COUNT(NewProp_FilePath_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_FilePath,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"FilePath",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FFilePath),
				alignof(FFilePath),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFilePath_CRC() { return 3658807553U; }
class UScriptStruct* FComponentReference::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FComponentReference_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FComponentReference, Z_Construct_UPackage__Script_Engine(), TEXT("ComponentReference"), sizeof(FComponentReference), Get_Z_Construct_UScriptStruct_FComponentReference_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FComponentReference(FComponentReference::StaticStruct, TEXT("/Script/Engine"), TEXT("ComponentReference"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFComponentReference
{
	FScriptStruct_Engine_StaticRegisterNativesFComponentReference()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("ComponentReference")),new UScriptStruct::TCppStructOps<FComponentReference>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFComponentReference;
	UScriptStruct* Z_Construct_UScriptStruct_FComponentReference()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FComponentReference_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("ComponentReference"), sizeof(FComponentReference), Get_Z_Construct_UScriptStruct_FComponentReference_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Struct that allows for different ways to reference a component.\nIf just an Actor is specified, will return RootComponent of that Actor." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FComponentReference>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ComponentProperty_MetaData[] = {
				{ "Category", "Component" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Name of component property to use" },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_ComponentProperty = { UE4CodeGen_Private::EPropertyClass::Name, "ComponentProperty", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FComponentReference, ComponentProperty), METADATA_PARAMS(NewProp_ComponentProperty_MetaData, ARRAY_COUNT(NewProp_ComponentProperty_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_OtherActor_MetaData[] = {
				{ "Category", "Component" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Pointer to a different Actor that owns the Component." },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_OtherActor = { UE4CodeGen_Private::EPropertyClass::Object, "OtherActor", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000801, 1, nullptr, STRUCT_OFFSET(FComponentReference, OtherActor), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(NewProp_OtherActor_MetaData, ARRAY_COUNT(NewProp_OtherActor_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ComponentProperty,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_OtherActor,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"ComponentReference",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FComponentReference),
				alignof(FComponentReference),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FComponentReference_CRC() { return 979870014U; }
class UScriptStruct* FConstrainComponentPropName::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FConstrainComponentPropName_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FConstrainComponentPropName, Z_Construct_UPackage__Script_Engine(), TEXT("ConstrainComponentPropName"), sizeof(FConstrainComponentPropName), Get_Z_Construct_UScriptStruct_FConstrainComponentPropName_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FConstrainComponentPropName(FConstrainComponentPropName::StaticStruct, TEXT("/Script/Engine"), TEXT("ConstrainComponentPropName"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFConstrainComponentPropName
{
	FScriptStruct_Engine_StaticRegisterNativesFConstrainComponentPropName()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("ConstrainComponentPropName")),new UScriptStruct::TCppStructOps<FConstrainComponentPropName>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFConstrainComponentPropName;
	UScriptStruct* Z_Construct_UScriptStruct_FConstrainComponentPropName()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FConstrainComponentPropName_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("ConstrainComponentPropName"), sizeof(FConstrainComponentPropName), Get_Z_Construct_UScriptStruct_FConstrainComponentPropName_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Struct used to specify the property name of the component to constrain" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FConstrainComponentPropName>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ComponentName_MetaData[] = {
				{ "Category", "Constraint" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Name of property" },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_ComponentName = { UE4CodeGen_Private::EPropertyClass::Name, "ComponentName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FConstrainComponentPropName, ComponentName), METADATA_PARAMS(NewProp_ComponentName_MetaData, ARRAY_COUNT(NewProp_ComponentName_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ComponentName,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"ConstrainComponentPropName",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FConstrainComponentPropName),
				alignof(FConstrainComponentPropName),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FConstrainComponentPropName_CRC() { return 886760329U; }
class UScriptStruct* FWalkableSlopeOverride::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FWalkableSlopeOverride_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FWalkableSlopeOverride, Z_Construct_UPackage__Script_Engine(), TEXT("WalkableSlopeOverride"), sizeof(FWalkableSlopeOverride), Get_Z_Construct_UScriptStruct_FWalkableSlopeOverride_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FWalkableSlopeOverride(FWalkableSlopeOverride::StaticStruct, TEXT("/Script/Engine"), TEXT("WalkableSlopeOverride"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFWalkableSlopeOverride
{
	FScriptStruct_Engine_StaticRegisterNativesFWalkableSlopeOverride()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("WalkableSlopeOverride")),new UScriptStruct::TCppStructOps<FWalkableSlopeOverride>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFWalkableSlopeOverride;
	UScriptStruct* Z_Construct_UScriptStruct_FWalkableSlopeOverride()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FWalkableSlopeOverride_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("WalkableSlopeOverride"), sizeof(FWalkableSlopeOverride), Get_Z_Construct_UScriptStruct_FWalkableSlopeOverride_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Struct allowing control over \"walkable\" normals, by allowing a restriction or relaxation of what steepness is normally walkable." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FWalkableSlopeOverride>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_WalkableSlopeAngle_MetaData[] = {
				{ "Category", "WalkableSlopeOverride" },
				{ "ClampMax", "90" },
				{ "ClampMin", "0" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Override walkable slope angle (in degrees), applying the rules of the Walkable Slope Behavior.\n@see GetWalkableSlopeAngle(), SetWalkableSlopeAngle()" },
				{ "UIMax", "90" },
				{ "UIMin", "0" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_WalkableSlopeAngle = { UE4CodeGen_Private::EPropertyClass::Float, "WalkableSlopeAngle", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FWalkableSlopeOverride, WalkableSlopeAngle), METADATA_PARAMS(NewProp_WalkableSlopeAngle_MetaData, ARRAY_COUNT(NewProp_WalkableSlopeAngle_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_WalkableSlopeBehavior_MetaData[] = {
				{ "Category", "WalkableSlopeOverride" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Behavior of this surface (whether we affect the walkable slope).\n@see GetWalkableSlopeBehavior(), SetWalkableSlopeBehavior()" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_WalkableSlopeBehavior = { UE4CodeGen_Private::EPropertyClass::Byte, "WalkableSlopeBehavior", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FWalkableSlopeOverride, WalkableSlopeBehavior), Z_Construct_UEnum_Engine_EWalkableSlopeBehavior, METADATA_PARAMS(NewProp_WalkableSlopeBehavior_MetaData, ARRAY_COUNT(NewProp_WalkableSlopeBehavior_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_WalkableSlopeAngle,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_WalkableSlopeBehavior,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"WalkableSlopeOverride",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FWalkableSlopeOverride),
				alignof(FWalkableSlopeOverride),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FWalkableSlopeOverride_CRC() { return 2577998766U; }
class UScriptStruct* FRepAttachment::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRepAttachment_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRepAttachment, Z_Construct_UPackage__Script_Engine(), TEXT("RepAttachment"), sizeof(FRepAttachment), Get_Z_Construct_UScriptStruct_FRepAttachment_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRepAttachment(FRepAttachment::StaticStruct, TEXT("/Script/Engine"), TEXT("RepAttachment"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRepAttachment
{
	FScriptStruct_Engine_StaticRegisterNativesFRepAttachment()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RepAttachment")),new UScriptStruct::TCppStructOps<FRepAttachment>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRepAttachment;
	UScriptStruct* Z_Construct_UScriptStruct_FRepAttachment()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRepAttachment_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RepAttachment"), sizeof(FRepAttachment), Get_Z_Construct_UScriptStruct_FRepAttachment_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Handles attachment replication to clients. Movement replication will not happen while AttachParent is non-nullptr" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRepAttachment>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AttachComponent_MetaData[] = {
				{ "EditInline", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_AttachComponent = { UE4CodeGen_Private::EPropertyClass::Object, "AttachComponent", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000080008, 1, nullptr, STRUCT_OFFSET(FRepAttachment, AttachComponent), Z_Construct_UClass_USceneComponent_NoRegister, METADATA_PARAMS(NewProp_AttachComponent_MetaData, ARRAY_COUNT(NewProp_AttachComponent_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AttachSocket_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_AttachSocket = { UE4CodeGen_Private::EPropertyClass::Name, "AttachSocket", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRepAttachment, AttachSocket), METADATA_PARAMS(NewProp_AttachSocket_MetaData, ARRAY_COUNT(NewProp_AttachSocket_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_RotationOffset_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_RotationOffset = { UE4CodeGen_Private::EPropertyClass::Struct, "RotationOffset", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRepAttachment, RotationOffset), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(NewProp_RotationOffset_MetaData, ARRAY_COUNT(NewProp_RotationOffset_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_RelativeScale3D_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_RelativeScale3D = { UE4CodeGen_Private::EPropertyClass::Struct, "RelativeScale3D", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRepAttachment, RelativeScale3D), Z_Construct_UScriptStruct_FVector_NetQuantize100, METADATA_PARAMS(NewProp_RelativeScale3D_MetaData, ARRAY_COUNT(NewProp_RelativeScale3D_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LocationOffset_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_LocationOffset = { UE4CodeGen_Private::EPropertyClass::Struct, "LocationOffset", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRepAttachment, LocationOffset), Z_Construct_UScriptStruct_FVector_NetQuantize100, METADATA_PARAMS(NewProp_LocationOffset_MetaData, ARRAY_COUNT(NewProp_LocationOffset_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AttachParent_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_AttachParent = { UE4CodeGen_Private::EPropertyClass::Object, "AttachParent", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRepAttachment, AttachParent), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(NewProp_AttachParent_MetaData, ARRAY_COUNT(NewProp_AttachParent_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AttachComponent,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AttachSocket,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_RotationOffset,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_RelativeScale3D,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LocationOffset,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AttachParent,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RepAttachment",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000005),
				sizeof(FRepAttachment),
				alignof(FRepAttachment),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRepAttachment_CRC() { return 3696162360U; }
class UScriptStruct* FRepMovement::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRepMovement_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRepMovement, Z_Construct_UPackage__Script_Engine(), TEXT("RepMovement"), sizeof(FRepMovement), Get_Z_Construct_UScriptStruct_FRepMovement_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRepMovement(FRepMovement::StaticStruct, TEXT("/Script/Engine"), TEXT("RepMovement"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRepMovement
{
	FScriptStruct_Engine_StaticRegisterNativesFRepMovement()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RepMovement")),new UScriptStruct::TCppStructOps<FRepMovement>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRepMovement;
	UScriptStruct* Z_Construct_UScriptStruct_FRepMovement()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRepMovement_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RepMovement"), sizeof(FRepMovement), Get_Z_Construct_UScriptStruct_FRepMovement_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Replicated movement data of our RootComponent.\nStruct used for efficient replication as velocity and location are generally replicated together (this saves a repindex)\nand velocity.Z is commonly zero (most position replications are for walking pawns)." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRepMovement>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_RotationQuantizationLevel_MetaData[] = {
				{ "Category", "Replication" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Allows tuning the compression level for replicated rotation. You should only need to change this from the default if you see visual artifacts." },
			};
#endif
			static const UE4CodeGen_Private::FEnumPropertyParams NewProp_RotationQuantizationLevel = { UE4CodeGen_Private::EPropertyClass::Enum, "RotationQuantizationLevel", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010040000010001, 1, nullptr, STRUCT_OFFSET(FRepMovement, RotationQuantizationLevel), Z_Construct_UEnum_Engine_ERotatorQuantization, METADATA_PARAMS(NewProp_RotationQuantizationLevel_MetaData, ARRAY_COUNT(NewProp_RotationQuantizationLevel_MetaData)) };
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_RotationQuantizationLevel_Underlying = { UE4CodeGen_Private::EPropertyClass::Byte, "UnderlyingType", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, nullptr, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_VelocityQuantizationLevel_MetaData[] = {
				{ "Category", "Replication" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Allows tuning the compression level for the replicated velocity vectors. You should only need to change this from the default if you see visual artifacts." },
			};
#endif
			static const UE4CodeGen_Private::FEnumPropertyParams NewProp_VelocityQuantizationLevel = { UE4CodeGen_Private::EPropertyClass::Enum, "VelocityQuantizationLevel", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010040000010001, 1, nullptr, STRUCT_OFFSET(FRepMovement, VelocityQuantizationLevel), Z_Construct_UEnum_Engine_EVectorQuantization, METADATA_PARAMS(NewProp_VelocityQuantizationLevel_MetaData, ARRAY_COUNT(NewProp_VelocityQuantizationLevel_MetaData)) };
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_VelocityQuantizationLevel_Underlying = { UE4CodeGen_Private::EPropertyClass::Byte, "UnderlyingType", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, nullptr, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LocationQuantizationLevel_MetaData[] = {
				{ "Category", "Replication" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Allows tuning the compression level for the replicated location vector. You should only need to change this from the default if you see visual artifacts." },
			};
#endif
			static const UE4CodeGen_Private::FEnumPropertyParams NewProp_LocationQuantizationLevel = { UE4CodeGen_Private::EPropertyClass::Enum, "LocationQuantizationLevel", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010040000010001, 1, nullptr, STRUCT_OFFSET(FRepMovement, LocationQuantizationLevel), Z_Construct_UEnum_Engine_EVectorQuantization, METADATA_PARAMS(NewProp_LocationQuantizationLevel_MetaData, ARRAY_COUNT(NewProp_LocationQuantizationLevel_MetaData)) };
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_LocationQuantizationLevel_Underlying = { UE4CodeGen_Private::EPropertyClass::Byte, "UnderlyingType", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, nullptr, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bRepPhysics_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If set, additional physic data (angular velocity) will be replicated." },
			};
#endif
			auto NewProp_bRepPhysics_SetBit = [](void* Obj){ ((FRepMovement*)Obj)->bRepPhysics = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bRepPhysics = { UE4CodeGen_Private::EPropertyClass::Bool, "bRepPhysics", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FRepMovement), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bRepPhysics_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bRepPhysics_MetaData, ARRAY_COUNT(NewProp_bRepPhysics_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bSimulatedPhysicSleep_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If set, RootComponent should be sleeping." },
			};
#endif
			auto NewProp_bSimulatedPhysicSleep_SetBit = [](void* Obj){ ((FRepMovement*)Obj)->bSimulatedPhysicSleep = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bSimulatedPhysicSleep = { UE4CodeGen_Private::EPropertyClass::Bool, "bSimulatedPhysicSleep", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FRepMovement), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bSimulatedPhysicSleep_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bSimulatedPhysicSleep_MetaData, ARRAY_COUNT(NewProp_bSimulatedPhysicSleep_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Rotation_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Rotation = { UE4CodeGen_Private::EPropertyClass::Struct, "Rotation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, STRUCT_OFFSET(FRepMovement, Rotation), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(NewProp_Rotation_MetaData, ARRAY_COUNT(NewProp_Rotation_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Location_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Location = { UE4CodeGen_Private::EPropertyClass::Struct, "Location", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, STRUCT_OFFSET(FRepMovement, Location), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_Location_MetaData, ARRAY_COUNT(NewProp_Location_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AngularVelocity_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_AngularVelocity = { UE4CodeGen_Private::EPropertyClass::Struct, "AngularVelocity", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, STRUCT_OFFSET(FRepMovement, AngularVelocity), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_AngularVelocity_MetaData, ARRAY_COUNT(NewProp_AngularVelocity_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LinearVelocity_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_LinearVelocity = { UE4CodeGen_Private::EPropertyClass::Struct, "LinearVelocity", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, STRUCT_OFFSET(FRepMovement, LinearVelocity), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_LinearVelocity_MetaData, ARRAY_COUNT(NewProp_LinearVelocity_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_RotationQuantizationLevel,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_RotationQuantizationLevel_Underlying,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_VelocityQuantizationLevel,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_VelocityQuantizationLevel_Underlying,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LocationQuantizationLevel,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LocationQuantizationLevel_Underlying,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bRepPhysics,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bSimulatedPhysicSleep,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Rotation,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Location,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AngularVelocity,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LinearVelocity,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RepMovement",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FRepMovement),
				alignof(FRepMovement),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRepMovement_CRC() { return 2198238881U; }
class UScriptStruct* FTimerHandle::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FTimerHandle_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FTimerHandle, Z_Construct_UPackage__Script_Engine(), TEXT("TimerHandle"), sizeof(FTimerHandle), Get_Z_Construct_UScriptStruct_FTimerHandle_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FTimerHandle(FTimerHandle::StaticStruct, TEXT("/Script/Engine"), TEXT("TimerHandle"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFTimerHandle
{
	FScriptStruct_Engine_StaticRegisterNativesFTimerHandle()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("TimerHandle")),new UScriptStruct::TCppStructOps<FTimerHandle>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFTimerHandle;
	UScriptStruct* Z_Construct_UScriptStruct_FTimerHandle()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FTimerHandle_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("TimerHandle"), sizeof(FTimerHandle), Get_Z_Construct_UScriptStruct_FTimerHandle_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Unique handle that can be used to distinguish timers that have identical delegates." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FTimerHandle>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Handle_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FUInt64PropertyParams NewProp_Handle = { UE4CodeGen_Private::EPropertyClass::UInt64, "Handle", RF_Public|RF_Transient|RF_MarkAsNative, 0x0040000000002000, 1, nullptr, STRUCT_OFFSET(FTimerHandle, Handle), METADATA_PARAMS(NewProp_Handle_MetaData, ARRAY_COUNT(NewProp_Handle_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Handle,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"TimerHandle",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FTimerHandle),
				alignof(FTimerHandle),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimerHandle_CRC() { return 19687704U; }
class UScriptStruct* FRadialDamageEvent::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRadialDamageEvent_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRadialDamageEvent, Z_Construct_UPackage__Script_Engine(), TEXT("RadialDamageEvent"), sizeof(FRadialDamageEvent), Get_Z_Construct_UScriptStruct_FRadialDamageEvent_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRadialDamageEvent(FRadialDamageEvent::StaticStruct, TEXT("/Script/Engine"), TEXT("RadialDamageEvent"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRadialDamageEvent
{
	FScriptStruct_Engine_StaticRegisterNativesFRadialDamageEvent()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RadialDamageEvent")),new UScriptStruct::TCppStructOps<FRadialDamageEvent>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRadialDamageEvent;
	UScriptStruct* Z_Construct_UScriptStruct_FRadialDamageEvent()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRadialDamageEvent_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RadialDamageEvent"), sizeof(FRadialDamageEvent), Get_Z_Construct_UScriptStruct_FRadialDamageEvent_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRadialDamageEvent>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ComponentHits_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "@fixme, will not replicate properly?  component pointer" },
			};
#endif
			static const UE4CodeGen_Private::FArrayPropertyParams NewProp_ComponentHits = { UE4CodeGen_Private::EPropertyClass::Array, "ComponentHits", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010008000000000, 1, nullptr, STRUCT_OFFSET(FRadialDamageEvent, ComponentHits), METADATA_PARAMS(NewProp_ComponentHits_MetaData, ARRAY_COUNT(NewProp_ComponentHits_MetaData)) };
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ComponentHits_Inner = { UE4CodeGen_Private::EPropertyClass::Struct, "ComponentHits", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000008000000000, 1, nullptr, 0, Z_Construct_UScriptStruct_FHitResult, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Origin_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Origin = { UE4CodeGen_Private::EPropertyClass::Struct, "Origin", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRadialDamageEvent, Origin), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_Origin_MetaData, ARRAY_COUNT(NewProp_Origin_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Params_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Params = { UE4CodeGen_Private::EPropertyClass::Struct, "Params", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRadialDamageEvent, Params), Z_Construct_UScriptStruct_FRadialDamageParams, METADATA_PARAMS(NewProp_Params_MetaData, ARRAY_COUNT(NewProp_Params_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ComponentHits,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ComponentHits_Inner,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Origin,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Params,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				Z_Construct_UScriptStruct_FDamageEvent,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RadialDamageEvent",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000205),
				sizeof(FRadialDamageEvent),
				alignof(FRadialDamageEvent),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRadialDamageEvent_CRC() { return 1644896368U; }
class UScriptStruct* FRadialDamageParams::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRadialDamageParams_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRadialDamageParams, Z_Construct_UPackage__Script_Engine(), TEXT("RadialDamageParams"), sizeof(FRadialDamageParams), Get_Z_Construct_UScriptStruct_FRadialDamageParams_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRadialDamageParams(FRadialDamageParams::StaticStruct, TEXT("/Script/Engine"), TEXT("RadialDamageParams"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRadialDamageParams
{
	FScriptStruct_Engine_StaticRegisterNativesFRadialDamageParams()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RadialDamageParams")),new UScriptStruct::TCppStructOps<FRadialDamageParams>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRadialDamageParams;
	UScriptStruct* Z_Construct_UScriptStruct_FRadialDamageParams()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRadialDamageParams_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RadialDamageParams"), sizeof(FRadialDamageParams), Get_Z_Construct_UScriptStruct_FRadialDamageParams_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRadialDamageParams>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DamageFalloff_MetaData[] = {
				{ "Category", "RadialDamageParams" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_DamageFalloff = { UE4CodeGen_Private::EPropertyClass::Float, "DamageFalloff", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FRadialDamageParams, DamageFalloff), METADATA_PARAMS(NewProp_DamageFalloff_MetaData, ARRAY_COUNT(NewProp_DamageFalloff_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_OuterRadius_MetaData[] = {
				{ "Category", "RadialDamageParams" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_OuterRadius = { UE4CodeGen_Private::EPropertyClass::Float, "OuterRadius", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FRadialDamageParams, OuterRadius), METADATA_PARAMS(NewProp_OuterRadius_MetaData, ARRAY_COUNT(NewProp_OuterRadius_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_InnerRadius_MetaData[] = {
				{ "Category", "RadialDamageParams" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_InnerRadius = { UE4CodeGen_Private::EPropertyClass::Float, "InnerRadius", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FRadialDamageParams, InnerRadius), METADATA_PARAMS(NewProp_InnerRadius_MetaData, ARRAY_COUNT(NewProp_InnerRadius_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MinimumDamage_MetaData[] = {
				{ "Category", "RadialDamageParams" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_MinimumDamage = { UE4CodeGen_Private::EPropertyClass::Float, "MinimumDamage", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FRadialDamageParams, MinimumDamage), METADATA_PARAMS(NewProp_MinimumDamage_MetaData, ARRAY_COUNT(NewProp_MinimumDamage_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BaseDamage_MetaData[] = {
				{ "Category", "RadialDamageParams" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_BaseDamage = { UE4CodeGen_Private::EPropertyClass::Float, "BaseDamage", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FRadialDamageParams, BaseDamage), METADATA_PARAMS(NewProp_BaseDamage_MetaData, ARRAY_COUNT(NewProp_BaseDamage_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DamageFalloff,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_OuterRadius,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_InnerRadius,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_MinimumDamage,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BaseDamage,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RadialDamageParams",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FRadialDamageParams),
				alignof(FRadialDamageParams),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRadialDamageParams_CRC() { return 1435217553U; }
class UScriptStruct* FPointDamageEvent::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FPointDamageEvent_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FPointDamageEvent, Z_Construct_UPackage__Script_Engine(), TEXT("PointDamageEvent"), sizeof(FPointDamageEvent), Get_Z_Construct_UScriptStruct_FPointDamageEvent_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FPointDamageEvent(FPointDamageEvent::StaticStruct, TEXT("/Script/Engine"), TEXT("PointDamageEvent"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFPointDamageEvent
{
	FScriptStruct_Engine_StaticRegisterNativesFPointDamageEvent()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("PointDamageEvent")),new UScriptStruct::TCppStructOps<FPointDamageEvent>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFPointDamageEvent;
	UScriptStruct* Z_Construct_UScriptStruct_FPointDamageEvent()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FPointDamageEvent_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("PointDamageEvent"), sizeof(FPointDamageEvent), Get_Z_Construct_UScriptStruct_FPointDamageEvent_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FPointDamageEvent>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_HitInfo_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_HitInfo = { UE4CodeGen_Private::EPropertyClass::Struct, "HitInfo", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010008000000000, 1, nullptr, STRUCT_OFFSET(FPointDamageEvent, HitInfo), Z_Construct_UScriptStruct_FHitResult, METADATA_PARAMS(NewProp_HitInfo_MetaData, ARRAY_COUNT(NewProp_HitInfo_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ShotDirection_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Direction the shot came from. Should be normalized." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ShotDirection = { UE4CodeGen_Private::EPropertyClass::Struct, "ShotDirection", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FPointDamageEvent, ShotDirection), Z_Construct_UScriptStruct_FVector_NetQuantizeNormal, METADATA_PARAMS(NewProp_ShotDirection_MetaData, ARRAY_COUNT(NewProp_ShotDirection_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Damage_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "skipping ImpulseMag for now" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Damage = { UE4CodeGen_Private::EPropertyClass::Float, "Damage", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FPointDamageEvent, Damage), METADATA_PARAMS(NewProp_Damage_MetaData, ARRAY_COUNT(NewProp_Damage_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_HitInfo,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ShotDirection,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Damage,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				Z_Construct_UScriptStruct_FDamageEvent,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"PointDamageEvent",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000205),
				sizeof(FPointDamageEvent),
				alignof(FPointDamageEvent),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPointDamageEvent_CRC() { return 2318703763U; }
class UScriptStruct* FDamageEvent::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FDamageEvent_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FDamageEvent, Z_Construct_UPackage__Script_Engine(), TEXT("DamageEvent"), sizeof(FDamageEvent), Get_Z_Construct_UScriptStruct_FDamageEvent_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FDamageEvent(FDamageEvent::StaticStruct, TEXT("/Script/Engine"), TEXT("DamageEvent"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFDamageEvent
{
	FScriptStruct_Engine_StaticRegisterNativesFDamageEvent()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("DamageEvent")),new UScriptStruct::TCppStructOps<FDamageEvent>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFDamageEvent;
	UScriptStruct* Z_Construct_UScriptStruct_FDamageEvent()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FDamageEvent_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("DamageEvent"), sizeof(FDamageEvent), Get_Z_Construct_UScriptStruct_FDamageEvent_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FDamageEvent>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DamageTypeClass_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Optional DamageType for this event.  If nullptr, UDamageType will be assumed." },
			};
#endif
			static const UE4CodeGen_Private::FClassPropertyParams NewProp_DamageTypeClass = { UE4CodeGen_Private::EPropertyClass::Class, "DamageTypeClass", RF_Public|RF_Transient|RF_MarkAsNative, 0x0014000000000000, 1, nullptr, STRUCT_OFFSET(FDamageEvent, DamageTypeClass), Z_Construct_UClass_UDamageType_NoRegister, Z_Construct_UClass_UClass, METADATA_PARAMS(NewProp_DamageTypeClass_MetaData, ARRAY_COUNT(NewProp_DamageTypeClass_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DamageTypeClass,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"DamageEvent",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FDamageEvent),
				alignof(FDamageEvent),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FDamageEvent_CRC() { return 633477413U; }
class UScriptStruct* FMeshBuildSettings::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FMeshBuildSettings_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FMeshBuildSettings, Z_Construct_UPackage__Script_Engine(), TEXT("MeshBuildSettings"), sizeof(FMeshBuildSettings), Get_Z_Construct_UScriptStruct_FMeshBuildSettings_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FMeshBuildSettings(FMeshBuildSettings::StaticStruct, TEXT("/Script/Engine"), TEXT("MeshBuildSettings"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFMeshBuildSettings
{
	FScriptStruct_Engine_StaticRegisterNativesFMeshBuildSettings()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("MeshBuildSettings")),new UScriptStruct::TCppStructOps<FMeshBuildSettings>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFMeshBuildSettings;
	UScriptStruct* Z_Construct_UScriptStruct_FMeshBuildSettings()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FMeshBuildSettings_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("MeshBuildSettings"), sizeof(FMeshBuildSettings), Get_Z_Construct_UScriptStruct_FMeshBuildSettings_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Settings applied when building a mesh." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FMeshBuildSettings>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DistanceFieldReplacementMesh_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_DistanceFieldReplacementMesh = { UE4CodeGen_Private::EPropertyClass::Object, "DistanceFieldReplacementMesh", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, DistanceFieldReplacementMesh), Z_Construct_UClass_UStaticMesh_NoRegister, METADATA_PARAMS(NewProp_DistanceFieldReplacementMesh_MetaData, ARRAY_COUNT(NewProp_DistanceFieldReplacementMesh_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DistanceFieldBias_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_DistanceFieldBias = { UE4CodeGen_Private::EPropertyClass::Float, "DistanceFieldBias", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000020000000, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, DistanceFieldBias_DEPRECATED), METADATA_PARAMS(NewProp_DistanceFieldBias_MetaData, ARRAY_COUNT(NewProp_DistanceFieldBias_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bGenerateDistanceFieldAsIfTwoSided_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "DisplayName", "Two-Sided Distance Field Generation" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Whether to generate the distance field treating every triangle hit as a front face.\nWhen enabled prevents the distance field from being discarded due to the mesh being open, but also lowers Distance Field AO quality." },
			};
#endif
			auto NewProp_bGenerateDistanceFieldAsIfTwoSided_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bGenerateDistanceFieldAsIfTwoSided = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bGenerateDistanceFieldAsIfTwoSided = { UE4CodeGen_Private::EPropertyClass::Bool, "bGenerateDistanceFieldAsIfTwoSided", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bGenerateDistanceFieldAsIfTwoSided_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bGenerateDistanceFieldAsIfTwoSided_MetaData, ARRAY_COUNT(NewProp_bGenerateDistanceFieldAsIfTwoSided_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DistanceFieldResolutionScale_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Scale to apply to the mesh when allocating the distance field volume texture.\nThe default scale is 1, which is assuming that the mesh will be placed unscaled in the world." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_DistanceFieldResolutionScale = { UE4CodeGen_Private::EPropertyClass::Float, "DistanceFieldResolutionScale", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, DistanceFieldResolutionScale), METADATA_PARAMS(NewProp_DistanceFieldResolutionScale_MetaData, ARRAY_COUNT(NewProp_DistanceFieldResolutionScale_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BuildScale3D_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "DisplayName", "Build Scale" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The local scale applied when building the mesh" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_BuildScale3D = { UE4CodeGen_Private::EPropertyClass::Struct, "BuildScale3D", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, BuildScale3D), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_BuildScale3D_MetaData, ARRAY_COUNT(NewProp_BuildScale3D_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BuildScale_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_BuildScale = { UE4CodeGen_Private::EPropertyClass::Float, "BuildScale", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000020000000, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, BuildScale_DEPRECATED), METADATA_PARAMS(NewProp_BuildScale_MetaData, ARRAY_COUNT(NewProp_BuildScale_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DstLightmapIndex_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "DisplayName", "Destination Lightmap Index" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_DstLightmapIndex = { UE4CodeGen_Private::EPropertyClass::Int, "DstLightmapIndex", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, DstLightmapIndex), METADATA_PARAMS(NewProp_DstLightmapIndex_MetaData, ARRAY_COUNT(NewProp_DstLightmapIndex_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_SrcLightmapIndex_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "DisplayName", "Source Lightmap Index" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_SrcLightmapIndex = { UE4CodeGen_Private::EPropertyClass::Int, "SrcLightmapIndex", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, SrcLightmapIndex), METADATA_PARAMS(NewProp_SrcLightmapIndex_MetaData, ARRAY_COUNT(NewProp_SrcLightmapIndex_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MinLightmapResolution_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_MinLightmapResolution = { UE4CodeGen_Private::EPropertyClass::Int, "MinLightmapResolution", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FMeshBuildSettings, MinLightmapResolution), METADATA_PARAMS(NewProp_MinLightmapResolution_MetaData, ARRAY_COUNT(NewProp_MinLightmapResolution_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bGenerateLightmapUVs_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewProp_bGenerateLightmapUVs_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bGenerateLightmapUVs = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bGenerateLightmapUVs = { UE4CodeGen_Private::EPropertyClass::Bool, "bGenerateLightmapUVs", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bGenerateLightmapUVs_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bGenerateLightmapUVs_MetaData, ARRAY_COUNT(NewProp_bGenerateLightmapUVs_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseFullPrecisionUVs_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, UVs will be stored at full floating point precision." },
			};
#endif
			auto NewProp_bUseFullPrecisionUVs_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bUseFullPrecisionUVs = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseFullPrecisionUVs = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseFullPrecisionUVs", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseFullPrecisionUVs_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseFullPrecisionUVs_MetaData, ARRAY_COUNT(NewProp_bUseFullPrecisionUVs_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseHighPrecisionTangentBasis_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Tangents will be stored at 16 bit vs 8 bit precision." },
			};
#endif
			auto NewProp_bUseHighPrecisionTangentBasis_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bUseHighPrecisionTangentBasis = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseHighPrecisionTangentBasis = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseHighPrecisionTangentBasis", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseHighPrecisionTangentBasis_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseHighPrecisionTangentBasis_MetaData, ARRAY_COUNT(NewProp_bUseHighPrecisionTangentBasis_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bBuildReversedIndexBuffer_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Required to optimize mesh in mirrored transform. Double index buffer size." },
			};
#endif
			auto NewProp_bBuildReversedIndexBuffer_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bBuildReversedIndexBuffer = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bBuildReversedIndexBuffer = { UE4CodeGen_Private::EPropertyClass::Bool, "bBuildReversedIndexBuffer", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bBuildReversedIndexBuffer_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bBuildReversedIndexBuffer_MetaData, ARRAY_COUNT(NewProp_bBuildReversedIndexBuffer_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bBuildAdjacencyBuffer_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Required for PNT tessellation but can be slow. Recommend disabling for larger meshes." },
			};
#endif
			auto NewProp_bBuildAdjacencyBuffer_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bBuildAdjacencyBuffer = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bBuildAdjacencyBuffer = { UE4CodeGen_Private::EPropertyClass::Bool, "bBuildAdjacencyBuffer", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bBuildAdjacencyBuffer_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bBuildAdjacencyBuffer_MetaData, ARRAY_COUNT(NewProp_bBuildAdjacencyBuffer_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bRemoveDegenerates_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, degenerate triangles will be removed." },
			};
#endif
			auto NewProp_bRemoveDegenerates_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bRemoveDegenerates = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bRemoveDegenerates = { UE4CodeGen_Private::EPropertyClass::Bool, "bRemoveDegenerates", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bRemoveDegenerates_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bRemoveDegenerates_MetaData, ARRAY_COUNT(NewProp_bRemoveDegenerates_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bRecomputeTangents_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, tangents in the raw mesh are ignored and recomputed." },
			};
#endif
			auto NewProp_bRecomputeTangents_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bRecomputeTangents = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bRecomputeTangents = { UE4CodeGen_Private::EPropertyClass::Bool, "bRecomputeTangents", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bRecomputeTangents_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bRecomputeTangents_MetaData, ARRAY_COUNT(NewProp_bRecomputeTangents_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bRecomputeNormals_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, normals in the raw mesh are ignored and recomputed." },
			};
#endif
			auto NewProp_bRecomputeNormals_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bRecomputeNormals = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bRecomputeNormals = { UE4CodeGen_Private::EPropertyClass::Bool, "bRecomputeNormals", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bRecomputeNormals_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bRecomputeNormals_MetaData, ARRAY_COUNT(NewProp_bRecomputeNormals_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseMikkTSpace_MetaData[] = {
				{ "Category", "BuildSettings" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, degenerate triangles will be removed." },
			};
#endif
			auto NewProp_bUseMikkTSpace_SetBit = [](void* Obj){ ((FMeshBuildSettings*)Obj)->bUseMikkTSpace = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseMikkTSpace = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseMikkTSpace", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FMeshBuildSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseMikkTSpace_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseMikkTSpace_MetaData, ARRAY_COUNT(NewProp_bUseMikkTSpace_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DistanceFieldReplacementMesh,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DistanceFieldBias,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bGenerateDistanceFieldAsIfTwoSided,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DistanceFieldResolutionScale,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BuildScale3D,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BuildScale,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DstLightmapIndex,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_SrcLightmapIndex,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_MinLightmapResolution,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bGenerateLightmapUVs,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseFullPrecisionUVs,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseHighPrecisionTangentBasis,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bBuildReversedIndexBuffer,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bBuildAdjacencyBuffer,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bRemoveDegenerates,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bRecomputeTangents,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bRecomputeNormals,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseMikkTSpace,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"MeshBuildSettings",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FMeshBuildSettings),
				alignof(FMeshBuildSettings),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMeshBuildSettings_CRC() { return 708401425U; }
class UScriptStruct* FPOV::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FPOV_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FPOV, Z_Construct_UPackage__Script_Engine(), TEXT("POV"), sizeof(FPOV), Get_Z_Construct_UScriptStruct_FPOV_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FPOV(FPOV::StaticStruct, TEXT("/Script/Engine"), TEXT("POV"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFPOV
{
	FScriptStruct_Engine_StaticRegisterNativesFPOV()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("POV")),new UScriptStruct::TCppStructOps<FPOV>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFPOV;
	UScriptStruct* Z_Construct_UScriptStruct_FPOV()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FPOV_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("POV"), sizeof(FPOV), Get_Z_Construct_UScriptStruct_FPOV_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Point Of View type." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FPOV>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_FOV_MetaData[] = {
				{ "Category", "POV" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "FOV angle" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_FOV = { UE4CodeGen_Private::EPropertyClass::Float, "FOV", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FPOV, FOV), METADATA_PARAMS(NewProp_FOV_MetaData, ARRAY_COUNT(NewProp_FOV_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Rotation_MetaData[] = {
				{ "Category", "POV" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Rotation" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Rotation = { UE4CodeGen_Private::EPropertyClass::Struct, "Rotation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FPOV, Rotation), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(NewProp_Rotation_MetaData, ARRAY_COUNT(NewProp_Rotation_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Location_MetaData[] = {
				{ "Category", "POV" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Location" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Location = { UE4CodeGen_Private::EPropertyClass::Struct, "Location", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FPOV, Location), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_Location_MetaData, ARRAY_COUNT(NewProp_Location_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_FOV,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Rotation,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Location,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"POV",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FPOV),
				alignof(FPOV),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPOV_CRC() { return 1480142696U; }
class UScriptStruct* FAnimUpdateRateParameters::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FAnimUpdateRateParameters_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAnimUpdateRateParameters, Z_Construct_UPackage__Script_Engine(), TEXT("AnimUpdateRateParameters"), sizeof(FAnimUpdateRateParameters), Get_Z_Construct_UScriptStruct_FAnimUpdateRateParameters_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAnimUpdateRateParameters(FAnimUpdateRateParameters::StaticStruct, TEXT("/Script/Engine"), TEXT("AnimUpdateRateParameters"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFAnimUpdateRateParameters
{
	FScriptStruct_Engine_StaticRegisterNativesFAnimUpdateRateParameters()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AnimUpdateRateParameters")),new UScriptStruct::TCppStructOps<FAnimUpdateRateParameters>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFAnimUpdateRateParameters;
	UScriptStruct* Z_Construct_UScriptStruct_FAnimUpdateRateParameters()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimUpdateRateParameters_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AnimUpdateRateParameters"), sizeof(FAnimUpdateRateParameters), Get_Z_Construct_UScriptStruct_FAnimUpdateRateParameters_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Container for Animation Update Rate parameters.\nThey are shared for all components of an Actor, so they can be updated in sync." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FAnimUpdateRateParameters>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ShiftBucket_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The bucket to use when deciding which counter to use to calculate shift values" },
			};
#endif
			static const UE4CodeGen_Private::FEnumPropertyParams NewProp_ShiftBucket = { UE4CodeGen_Private::EPropertyClass::Enum, "ShiftBucket", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, ShiftBucket), Z_Construct_UEnum_Engine_EUpdateRateShiftBucket, METADATA_PARAMS(NewProp_ShiftBucket_MetaData, ARRAY_COUNT(NewProp_ShiftBucket_MetaData)) };
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_ShiftBucket_Underlying = { UE4CodeGen_Private::EPropertyClass::Byte, "UnderlyingType", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, nullptr, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_MaxEvalRateForInterpolation_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Max Evaluation Rate allowed for interpolation to be enabled. Beyond, interpolation will be turned off." },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_MaxEvalRateForInterpolation = { UE4CodeGen_Private::EPropertyClass::Int, "MaxEvalRateForInterpolation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, MaxEvalRateForInterpolation), METADATA_PARAMS(NewProp_MaxEvalRateForInterpolation_MetaData, ARRAY_COUNT(NewProp_MaxEvalRateForInterpolation_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LODToFrameSkipMap_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Map of LOD levels to frame skip amounts. if bShouldUseLodMap is set these values will be used for\nthe frameskip amounts and the distance factor thresholds will be ignored. The flag and these values\nshould be configured using the customization callback when parameters are created for a component.\n\nNote that this is # of frames to skip, so if you have 20, that means every 21th frame, it will update, and evaluate." },
			};
#endif
			static const UE4CodeGen_Private::FMapPropertyParams NewProp_LODToFrameSkipMap = { UE4CodeGen_Private::EPropertyClass::Map, "LODToFrameSkipMap", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, LODToFrameSkipMap), METADATA_PARAMS(NewProp_LODToFrameSkipMap_MetaData, ARRAY_COUNT(NewProp_LODToFrameSkipMap_MetaData)) };
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_LODToFrameSkipMap_Key_KeyProp = { UE4CodeGen_Private::EPropertyClass::Int, "LODToFrameSkipMap_Key", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, METADATA_PARAMS(nullptr, 0) };
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_LODToFrameSkipMap_ValueProp = { UE4CodeGen_Private::EPropertyClass::Int, "LODToFrameSkipMap", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 1, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BaseVisibleDistanceFactorThesholds_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Array of MaxDistanceFactor to use for AnimUpdateRate when mesh is visible (rendered).\nMaxDistanceFactor is size on screen, as used by LODs\nExample:\n            BaseVisibleDistanceFactorThesholds.Add(0.4f)\n            BaseVisibleDistanceFactorThesholds.Add(0.2f)\nmeans:\n            0 frame skip, MaxDistanceFactor > 0.4f\n            1 frame skip, MaxDistanceFactor > 0.2f\n            2 frame skip, MaxDistanceFactor > 0.0f" },
			};
#endif
			static const UE4CodeGen_Private::FArrayPropertyParams NewProp_BaseVisibleDistanceFactorThesholds = { UE4CodeGen_Private::EPropertyClass::Array, "BaseVisibleDistanceFactorThesholds", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, BaseVisibleDistanceFactorThesholds), METADATA_PARAMS(NewProp_BaseVisibleDistanceFactorThesholds_MetaData, ARRAY_COUNT(NewProp_BaseVisibleDistanceFactorThesholds_MetaData)) };
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_BaseVisibleDistanceFactorThesholds_Inner = { UE4CodeGen_Private::EPropertyClass::Float, "BaseVisibleDistanceFactorThesholds", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BaseNonRenderedUpdateRate_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Rate of animation evaluation when non rendered (off screen and dedicated servers).\na value of 4 means evaluated 1 frame, then 3 frames skipped" },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_BaseNonRenderedUpdateRate = { UE4CodeGen_Private::EPropertyClass::Int, "BaseNonRenderedUpdateRate", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, BaseNonRenderedUpdateRate), METADATA_PARAMS(NewProp_BaseNonRenderedUpdateRate_MetaData, ARRAY_COUNT(NewProp_BaseNonRenderedUpdateRate_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AdditionalTime_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Total time of the last series of skipped updates" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_AdditionalTime = { UE4CodeGen_Private::EPropertyClass::Float, "AdditionalTime", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, AdditionalTime), METADATA_PARAMS(NewProp_AdditionalTime_MetaData, ARRAY_COUNT(NewProp_AdditionalTime_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_TickedPoseOffestTime_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Track time we have lost via skipping" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_TickedPoseOffestTime = { UE4CodeGen_Private::EPropertyClass::Float, "TickedPoseOffestTime", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000002000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, TickedPoseOffestTime), METADATA_PARAMS(NewProp_TickedPoseOffestTime_MetaData, ARRAY_COUNT(NewProp_TickedPoseOffestTime_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bSkipEvaluation_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "(This frame) animation evaluation should be skipped." },
			};
#endif
			auto NewProp_bSkipEvaluation_SetBit = [](void* Obj){ ((FAnimUpdateRateParameters*)Obj)->bSkipEvaluation = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bSkipEvaluation = { UE4CodeGen_Private::EPropertyClass::Bool, "bSkipEvaluation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FAnimUpdateRateParameters), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bSkipEvaluation_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bSkipEvaluation_MetaData, ARRAY_COUNT(NewProp_bSkipEvaluation_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bSkipUpdate_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "(This frame) animation update should be skipped." },
			};
#endif
			auto NewProp_bSkipUpdate_SetBit = [](void* Obj){ ((FAnimUpdateRateParameters*)Obj)->bSkipUpdate = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bSkipUpdate = { UE4CodeGen_Private::EPropertyClass::Bool, "bSkipUpdate", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FAnimUpdateRateParameters), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bSkipUpdate_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bSkipUpdate_MetaData, ARRAY_COUNT(NewProp_bSkipUpdate_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bShouldUseMinLod_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If set, LOD/Frameskip map will be queried with mesh's MinLodModel instead of current LOD (PredictedLODLevel)" },
			};
#endif
			auto NewProp_bShouldUseMinLod_SetBit = [](void* Obj){ ((FAnimUpdateRateParameters*)Obj)->bShouldUseMinLod = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bShouldUseMinLod = { UE4CodeGen_Private::EPropertyClass::Bool, "bShouldUseMinLod", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FAnimUpdateRateParameters), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bShouldUseMinLod_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bShouldUseMinLod_MetaData, ARRAY_COUNT(NewProp_bShouldUseMinLod_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bShouldUseLodMap_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Whether or not to use the defined LOD/Frameskip map instead of separate distance factor thresholds" },
			};
#endif
			auto NewProp_bShouldUseLodMap_SetBit = [](void* Obj){ ((FAnimUpdateRateParameters*)Obj)->bShouldUseLodMap = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bShouldUseLodMap = { UE4CodeGen_Private::EPropertyClass::Bool, "bShouldUseLodMap", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FAnimUpdateRateParameters), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bShouldUseLodMap_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bShouldUseLodMap_MetaData, ARRAY_COUNT(NewProp_bShouldUseLodMap_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bInterpolateSkippedFrames_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "When skipping a frame, should it be interpolated or frozen?" },
			};
#endif
			auto NewProp_bInterpolateSkippedFrames_SetBit = [](void* Obj){ ((FAnimUpdateRateParameters*)Obj)->bInterpolateSkippedFrames = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bInterpolateSkippedFrames = { UE4CodeGen_Private::EPropertyClass::Bool, "bInterpolateSkippedFrames", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FAnimUpdateRateParameters), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bInterpolateSkippedFrames_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bInterpolateSkippedFrames_MetaData, ARRAY_COUNT(NewProp_bInterpolateSkippedFrames_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EvaluationRate_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "How often animation will be evaluated. 1 = every frame, 2 = every 2 frames, etc.\nhas to be a multiple of UpdateRate." },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_EvaluationRate = { UE4CodeGen_Private::EPropertyClass::Int, "EvaluationRate", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, EvaluationRate), METADATA_PARAMS(NewProp_EvaluationRate_MetaData, ARRAY_COUNT(NewProp_EvaluationRate_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_UpdateRate_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "How often animation will be updated/ticked. 1 = every frame, 2 = every 2 frames, etc." },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_UpdateRate = { UE4CodeGen_Private::EPropertyClass::Int, "UpdateRate", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimUpdateRateParameters, UpdateRate), METADATA_PARAMS(NewProp_UpdateRate_MetaData, ARRAY_COUNT(NewProp_UpdateRate_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ShiftBucket,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ShiftBucket_Underlying,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_MaxEvalRateForInterpolation,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LODToFrameSkipMap,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LODToFrameSkipMap_Key_KeyProp,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LODToFrameSkipMap_ValueProp,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BaseVisibleDistanceFactorThesholds,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BaseVisibleDistanceFactorThesholds_Inner,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BaseNonRenderedUpdateRate,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AdditionalTime,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_TickedPoseOffestTime,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bSkipEvaluation,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bSkipUpdate,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bShouldUseMinLod,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bShouldUseLodMap,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bInterpolateSkippedFrames,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EvaluationRate,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_UpdateRate,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"AnimUpdateRateParameters",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FAnimUpdateRateParameters),
				alignof(FAnimUpdateRateParameters),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimUpdateRateParameters_CRC() { return 133728108U; }
class UScriptStruct* FAnimSlotDesc::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FAnimSlotDesc_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAnimSlotDesc, Z_Construct_UPackage__Script_Engine(), TEXT("AnimSlotDesc"), sizeof(FAnimSlotDesc), Get_Z_Construct_UScriptStruct_FAnimSlotDesc_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAnimSlotDesc(FAnimSlotDesc::StaticStruct, TEXT("/Script/Engine"), TEXT("AnimSlotDesc"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFAnimSlotDesc
{
	FScriptStruct_Engine_StaticRegisterNativesFAnimSlotDesc()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AnimSlotDesc")),new UScriptStruct::TCppStructOps<FAnimSlotDesc>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFAnimSlotDesc;
	UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotDesc()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimSlotDesc_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AnimSlotDesc"), sizeof(FAnimSlotDesc), Get_Z_Construct_UScriptStruct_FAnimSlotDesc_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Used to indicate each slot name and how many channels they have." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FAnimSlotDesc>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_NumChannels_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Number of channels that are available in this slot." },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_NumChannels = { UE4CodeGen_Private::EPropertyClass::Int, "NumChannels", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimSlotDesc, NumChannels), METADATA_PARAMS(NewProp_NumChannels_MetaData, ARRAY_COUNT(NewProp_NumChannels_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_SlotName_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Name of the slot." },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_SlotName = { UE4CodeGen_Private::EPropertyClass::Name, "SlotName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimSlotDesc, SlotName), METADATA_PARAMS(NewProp_SlotName_MetaData, ARRAY_COUNT(NewProp_SlotName_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_NumChannels,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_SlotName,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"AnimSlotDesc",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FAnimSlotDesc),
				alignof(FAnimSlotDesc),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimSlotDesc_CRC() { return 1754722842U; }
class UScriptStruct* FAnimSlotInfo::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FAnimSlotInfo_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FAnimSlotInfo, Z_Construct_UPackage__Script_Engine(), TEXT("AnimSlotInfo"), sizeof(FAnimSlotInfo), Get_Z_Construct_UScriptStruct_FAnimSlotInfo_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FAnimSlotInfo(FAnimSlotInfo::StaticStruct, TEXT("/Script/Engine"), TEXT("AnimSlotInfo"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFAnimSlotInfo
{
	FScriptStruct_Engine_StaticRegisterNativesFAnimSlotInfo()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("AnimSlotInfo")),new UScriptStruct::TCppStructOps<FAnimSlotInfo>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFAnimSlotInfo;
	UScriptStruct* Z_Construct_UScriptStruct_FAnimSlotInfo()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FAnimSlotInfo_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("AnimSlotInfo"), sizeof(FAnimSlotInfo), Get_Z_Construct_UScriptStruct_FAnimSlotInfo_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Struct used for passing information from Matinee to an Actor for blending animations during a sequence." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FAnimSlotInfo>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ChannelWeights_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Strength of each Channel within this Slot. Channel indexs are determined by track order in Matinee." },
			};
#endif
			static const UE4CodeGen_Private::FArrayPropertyParams NewProp_ChannelWeights = { UE4CodeGen_Private::EPropertyClass::Array, "ChannelWeights", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimSlotInfo, ChannelWeights), METADATA_PARAMS(NewProp_ChannelWeights_MetaData, ARRAY_COUNT(NewProp_ChannelWeights_MetaData)) };
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ChannelWeights_Inner = { UE4CodeGen_Private::EPropertyClass::Float, "ChannelWeights", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_SlotName_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Name of slot that we want to play the animtion in." },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_SlotName = { UE4CodeGen_Private::EPropertyClass::Name, "SlotName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FAnimSlotInfo, SlotName), METADATA_PARAMS(NewProp_SlotName_MetaData, ARRAY_COUNT(NewProp_SlotName_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ChannelWeights,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ChannelWeights_Inner,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_SlotName,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"AnimSlotInfo",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FAnimSlotInfo),
				alignof(FAnimSlotInfo),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FAnimSlotInfo_CRC() { return 4072149324U; }
class UScriptStruct* FMTDResult::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FMTDResult_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FMTDResult, Z_Construct_UPackage__Script_Engine(), TEXT("MTDResult"), sizeof(FMTDResult), Get_Z_Construct_UScriptStruct_FMTDResult_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FMTDResult(FMTDResult::StaticStruct, TEXT("/Script/Engine"), TEXT("MTDResult"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFMTDResult
{
	FScriptStruct_Engine_StaticRegisterNativesFMTDResult()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("MTDResult")),new UScriptStruct::TCppStructOps<FMTDResult>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFMTDResult;
	UScriptStruct* Z_Construct_UScriptStruct_FMTDResult()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FMTDResult_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("MTDResult"), sizeof(FMTDResult), Get_Z_Construct_UScriptStruct_FMTDResult_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Structure containing information about minimum translation direction (MTD)" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FMTDResult>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Distance_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Distance required to move along the MTD vector (Direction)." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Distance = { UE4CodeGen_Private::EPropertyClass::Float, "Distance", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FMTDResult, Distance), METADATA_PARAMS(NewProp_Distance_MetaData, ARRAY_COUNT(NewProp_Distance_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Direction_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Normalized direction of the minimum translation required to fix penetration." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Direction = { UE4CodeGen_Private::EPropertyClass::Struct, "Direction", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FMTDResult, Direction), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_Direction_MetaData, ARRAY_COUNT(NewProp_Direction_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Distance,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Direction,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"MTDResult",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FMTDResult),
				alignof(FMTDResult),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMTDResult_CRC() { return 1053003498U; }
class UScriptStruct* FOverlapResult::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FOverlapResult_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FOverlapResult, Z_Construct_UPackage__Script_Engine(), TEXT("OverlapResult"), sizeof(FOverlapResult), Get_Z_Construct_UScriptStruct_FOverlapResult_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FOverlapResult(FOverlapResult::StaticStruct, TEXT("/Script/Engine"), TEXT("OverlapResult"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFOverlapResult
{
	FScriptStruct_Engine_StaticRegisterNativesFOverlapResult()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("OverlapResult")),new UScriptStruct::TCppStructOps<FOverlapResult>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFOverlapResult;
	UScriptStruct* Z_Construct_UScriptStruct_FOverlapResult()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FOverlapResult_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("OverlapResult"), sizeof(FOverlapResult), Get_Z_Construct_UScriptStruct_FOverlapResult_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Structure containing information about one hit of an overlap test" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FOverlapResult>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bBlockingHit_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Indicates if this hit was requesting a block - if false, was requesting a touch instead" },
			};
#endif
			auto NewProp_bBlockingHit_SetBit = [](void* Obj){ ((FOverlapResult*)Obj)->bBlockingHit = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bBlockingHit = { UE4CodeGen_Private::EPropertyClass::Bool, "bBlockingHit", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FOverlapResult), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bBlockingHit_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bBlockingHit_MetaData, ARRAY_COUNT(NewProp_bBlockingHit_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Component_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "PrimitiveComponent that the check hit." },
			};
#endif
			static const UE4CodeGen_Private::FWeakObjectPropertyParams NewProp_Component = { UE4CodeGen_Private::EPropertyClass::WeakObject, "Component", RF_Public|RF_Transient|RF_MarkAsNative, 0x0014000000080008, 1, nullptr, STRUCT_OFFSET(FOverlapResult, Component), Z_Construct_UClass_UPrimitiveComponent_NoRegister, METADATA_PARAMS(NewProp_Component_MetaData, ARRAY_COUNT(NewProp_Component_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Actor_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Actor that the check hit." },
			};
#endif
			static const UE4CodeGen_Private::FWeakObjectPropertyParams NewProp_Actor = { UE4CodeGen_Private::EPropertyClass::WeakObject, "Actor", RF_Public|RF_Transient|RF_MarkAsNative, 0x0014000000000000, 1, nullptr, STRUCT_OFFSET(FOverlapResult, Actor), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(NewProp_Actor_MetaData, ARRAY_COUNT(NewProp_Actor_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bBlockingHit,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Component,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Actor,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"OverlapResult",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000205),
				sizeof(FOverlapResult),
				alignof(FOverlapResult),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FOverlapResult_CRC() { return 3882981372U; }
class UScriptStruct* FHitResult::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FHitResult_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FHitResult, Z_Construct_UPackage__Script_Engine(), TEXT("HitResult"), sizeof(FHitResult), Get_Z_Construct_UScriptStruct_FHitResult_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FHitResult(FHitResult::StaticStruct, TEXT("/Script/Engine"), TEXT("HitResult"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFHitResult
{
	FScriptStruct_Engine_StaticRegisterNativesFHitResult()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("HitResult")),new UScriptStruct::TCppStructOps<FHitResult>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFHitResult;
	UScriptStruct* Z_Construct_UScriptStruct_FHitResult()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FHitResult_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("HitResult"), sizeof(FHitResult), Get_Z_Construct_UScriptStruct_FHitResult_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "HasNativeBreak", "Engine.GameplayStatics.BreakHitResult" },
				{ "HasNativeMake", "Engine.GameplayStatics.MakeHitResult" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Structure containing information about one hit of a trace, such as point of impact and surface normal at that point." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FHitResult>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_FaceIndex_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Face index we hit (for complex hits with triangle meshes)." },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_FaceIndex = { UE4CodeGen_Private::EPropertyClass::Int, "FaceIndex", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, FaceIndex), METADATA_PARAMS(NewProp_FaceIndex_MetaData, ARRAY_COUNT(NewProp_FaceIndex_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BoneName_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Name of bone we hit (for skeletal meshes)." },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_BoneName = { UE4CodeGen_Private::EPropertyClass::Name, "BoneName", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, BoneName), METADATA_PARAMS(NewProp_BoneName_MetaData, ARRAY_COUNT(NewProp_BoneName_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Component_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "PrimitiveComponent hit by the trace." },
			};
#endif
			static const UE4CodeGen_Private::FWeakObjectPropertyParams NewProp_Component = { UE4CodeGen_Private::EPropertyClass::WeakObject, "Component", RF_Public|RF_Transient|RF_MarkAsNative, 0x0014000000080008, 1, nullptr, STRUCT_OFFSET(FHitResult, Component), Z_Construct_UClass_UPrimitiveComponent_NoRegister, METADATA_PARAMS(NewProp_Component_MetaData, ARRAY_COUNT(NewProp_Component_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Actor_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Actor hit by the trace." },
			};
#endif
			static const UE4CodeGen_Private::FWeakObjectPropertyParams NewProp_Actor = { UE4CodeGen_Private::EPropertyClass::WeakObject, "Actor", RF_Public|RF_Transient|RF_MarkAsNative, 0x0014000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, Actor), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(NewProp_Actor_MetaData, ARRAY_COUNT(NewProp_Actor_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_PhysMaterial_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Physical material that was hit.\n@note Must set bReturnPhysicalMaterial on the swept PrimitiveComponent or in the query params for this to be returned." },
			};
#endif
			static const UE4CodeGen_Private::FWeakObjectPropertyParams NewProp_PhysMaterial = { UE4CodeGen_Private::EPropertyClass::WeakObject, "PhysMaterial", RF_Public|RF_Transient|RF_MarkAsNative, 0x0014000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, PhysMaterial), Z_Construct_UClass_UPhysicalMaterial_NoRegister, METADATA_PARAMS(NewProp_PhysMaterial_MetaData, ARRAY_COUNT(NewProp_PhysMaterial_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Item_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Extra data about item that was hit (hit primitive specific)." },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_Item = { UE4CodeGen_Private::EPropertyClass::Int, "Item", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, Item), METADATA_PARAMS(NewProp_Item_MetaData, ARRAY_COUNT(NewProp_Item_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_PenetrationDepth_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If this test started in penetration (bStartPenetrating is true) and a depenetration vector can be computed,\nthis value is the distance along Normal that will result in moving out of penetration.\nIf the distance cannot be computed, this distance will be zero." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_PenetrationDepth = { UE4CodeGen_Private::EPropertyClass::Float, "PenetrationDepth", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, PenetrationDepth), METADATA_PARAMS(NewProp_PenetrationDepth_MetaData, ARRAY_COUNT(NewProp_PenetrationDepth_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_TraceEnd_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "End location of the trace; this is NOT where the impact occurred (if any), but the furthest point in the attempted sweep.\nFor example if a sphere is swept against the world, this would be the center of the sphere if there was no blocking hit." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_TraceEnd = { UE4CodeGen_Private::EPropertyClass::Struct, "TraceEnd", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, TraceEnd), Z_Construct_UScriptStruct_FVector_NetQuantize, METADATA_PARAMS(NewProp_TraceEnd_MetaData, ARRAY_COUNT(NewProp_TraceEnd_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_TraceStart_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Start location of the trace.\nFor example if a sphere is swept against the world, this is the starting location of the center of the sphere." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_TraceStart = { UE4CodeGen_Private::EPropertyClass::Struct, "TraceStart", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, TraceStart), Z_Construct_UScriptStruct_FVector_NetQuantize, METADATA_PARAMS(NewProp_TraceStart_MetaData, ARRAY_COUNT(NewProp_TraceStart_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ImpactNormal_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Normal of the hit in world space, for the object that was hit by the sweep, if any.\nFor example if a box hits a flat plane, this is a normalized vector pointing out from the plane.\nIn the case of impact with a corner or edge of a surface, usually the \"most opposing\" normal (opposed to the query direction) is chosen." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ImpactNormal = { UE4CodeGen_Private::EPropertyClass::Struct, "ImpactNormal", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, ImpactNormal), Z_Construct_UScriptStruct_FVector_NetQuantizeNormal, METADATA_PARAMS(NewProp_ImpactNormal_MetaData, ARRAY_COUNT(NewProp_ImpactNormal_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Normal_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Normal of the hit in world space, for the object that was swept. Equal to ImpactNormal for line tests.\nThis is computed for capsules and spheres, otherwise it will be the same as ImpactNormal.\nExample: for a sphere trace test, this is a normalized vector pointing in towards the center of the sphere at the point of impact." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Normal = { UE4CodeGen_Private::EPropertyClass::Struct, "Normal", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, Normal), Z_Construct_UScriptStruct_FVector_NetQuantizeNormal, METADATA_PARAMS(NewProp_Normal_MetaData, ARRAY_COUNT(NewProp_Normal_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ImpactPoint_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Location in world space of the actual contact of the trace shape (box, sphere, ray, etc) with the impacted object.\nExample: for a sphere trace test, this is the point where the surface of the sphere touches the other object.\n@note: In the case of initial overlap (bStartPenetrating=true), ImpactPoint will be the same as Location because there is no meaningful single impact point to report." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ImpactPoint = { UE4CodeGen_Private::EPropertyClass::Struct, "ImpactPoint", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, ImpactPoint), Z_Construct_UScriptStruct_FVector_NetQuantize, METADATA_PARAMS(NewProp_ImpactPoint_MetaData, ARRAY_COUNT(NewProp_ImpactPoint_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Location_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The location in world space where the moving shape would end up against the impacted object, if there is a hit. Equal to the point of impact for line tests.\nExample: for a sphere trace test, this is the point where the center of the sphere would be located when it touched the other object.\nFor swept movement (but not queries) this may not equal the final location of the shape since hits are pulled back slightly to prevent precision issues from overlapping another surface." },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Location = { UE4CodeGen_Private::EPropertyClass::Struct, "Location", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, Location), Z_Construct_UScriptStruct_FVector_NetQuantize, METADATA_PARAMS(NewProp_Location_MetaData, ARRAY_COUNT(NewProp_Location_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Distance_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The distance from the TraceStart to the Location in world space. This value is 0 if there was an initial overlap (trace started inside another colliding object)." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Distance = { UE4CodeGen_Private::EPropertyClass::Float, "Distance", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, Distance), METADATA_PARAMS(NewProp_Distance_MetaData, ARRAY_COUNT(NewProp_Distance_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Time_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "'Time' of impact along trace direction (ranging from 0.0 to 1.0) if there is a hit, indicating time between TraceStart and TraceEnd.\nFor swept movement (but not queries) this may be pulled back slightly from the actual time of impact, to prevent precision problems with adjacent geometry." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Time = { UE4CodeGen_Private::EPropertyClass::Float, "Time", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FHitResult, Time), METADATA_PARAMS(NewProp_Time_MetaData, ARRAY_COUNT(NewProp_Time_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bStartPenetrating_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Whether the trace started in penetration, i.e. with an initial blocking overlap.\nIn the case of penetration, if PenetrationDepth > 0.f, then it will represent the distance along the Normal vector that will result in\nminimal contact between the swept shape and the object that was hit. In this case, ImpactNormal will be the normal opposed to movement at that location\n(ie, Normal may not equal ImpactNormal). ImpactPoint will be the same as Location, since there is no single impact point to report." },
			};
#endif
			auto NewProp_bStartPenetrating_SetBit = [](void* Obj){ ((FHitResult*)Obj)->bStartPenetrating = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bStartPenetrating = { UE4CodeGen_Private::EPropertyClass::Bool, "bStartPenetrating", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FHitResult), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bStartPenetrating_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bStartPenetrating_MetaData, ARRAY_COUNT(NewProp_bStartPenetrating_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bBlockingHit_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Indicates if this hit was a result of blocking collision. If false, there was no hit or it was an overlap/touch instead." },
			};
#endif
			auto NewProp_bBlockingHit_SetBit = [](void* Obj){ ((FHitResult*)Obj)->bBlockingHit = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bBlockingHit = { UE4CodeGen_Private::EPropertyClass::Bool, "bBlockingHit", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FHitResult), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bBlockingHit_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bBlockingHit_MetaData, ARRAY_COUNT(NewProp_bBlockingHit_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_FaceIndex,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BoneName,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Component,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Actor,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_PhysMaterial,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Item,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_PenetrationDepth,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_TraceEnd,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_TraceStart,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ImpactNormal,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Normal,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ImpactPoint,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Location,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Distance,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Time,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bStartPenetrating,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bBlockingHit,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"HitResult",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000205),
				sizeof(FHitResult),
				alignof(FHitResult),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FHitResult_CRC() { return 2581762521U; }
class UScriptStruct* FPrimitiveMaterialRef::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FPrimitiveMaterialRef_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FPrimitiveMaterialRef, Z_Construct_UPackage__Script_Engine(), TEXT("PrimitiveMaterialRef"), sizeof(FPrimitiveMaterialRef), Get_Z_Construct_UScriptStruct_FPrimitiveMaterialRef_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FPrimitiveMaterialRef(FPrimitiveMaterialRef::StaticStruct, TEXT("/Script/Engine"), TEXT("PrimitiveMaterialRef"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFPrimitiveMaterialRef
{
	FScriptStruct_Engine_StaticRegisterNativesFPrimitiveMaterialRef()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("PrimitiveMaterialRef")),new UScriptStruct::TCppStructOps<FPrimitiveMaterialRef>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFPrimitiveMaterialRef;
	UScriptStruct* Z_Construct_UScriptStruct_FPrimitiveMaterialRef()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FPrimitiveMaterialRef_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("PrimitiveMaterialRef"), sizeof(FPrimitiveMaterialRef), Get_Z_Construct_UScriptStruct_FPrimitiveMaterialRef_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Reference to a specific material in a PrimitiveComponent." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FPrimitiveMaterialRef>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ElementIndex_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FIntPropertyParams NewProp_ElementIndex = { UE4CodeGen_Private::EPropertyClass::Int, "ElementIndex", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FPrimitiveMaterialRef, ElementIndex), METADATA_PARAMS(NewProp_ElementIndex_MetaData, ARRAY_COUNT(NewProp_ElementIndex_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Decal_MetaData[] = {
				{ "EditInline", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_Decal = { UE4CodeGen_Private::EPropertyClass::Object, "Decal", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000080008, 1, nullptr, STRUCT_OFFSET(FPrimitiveMaterialRef, Decal), Z_Construct_UClass_UDecalComponent_NoRegister, METADATA_PARAMS(NewProp_Decal_MetaData, ARRAY_COUNT(NewProp_Decal_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Primitive_MetaData[] = {
				{ "EditInline", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_Primitive = { UE4CodeGen_Private::EPropertyClass::Object, "Primitive", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000080008, 1, nullptr, STRUCT_OFFSET(FPrimitiveMaterialRef, Primitive), Z_Construct_UClass_UPrimitiveComponent_NoRegister, METADATA_PARAMS(NewProp_Primitive_MetaData, ARRAY_COUNT(NewProp_Primitive_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ElementIndex,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Decal,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Primitive,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"PrimitiveMaterialRef",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000005),
				sizeof(FPrimitiveMaterialRef),
				alignof(FPrimitiveMaterialRef),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPrimitiveMaterialRef_CRC() { return 953967091U; }
class UScriptStruct* FSwarmDebugOptions::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FSwarmDebugOptions_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FSwarmDebugOptions, Z_Construct_UPackage__Script_Engine(), TEXT("SwarmDebugOptions"), sizeof(FSwarmDebugOptions), Get_Z_Construct_UScriptStruct_FSwarmDebugOptions_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FSwarmDebugOptions(FSwarmDebugOptions::StaticStruct, TEXT("/Script/Engine"), TEXT("SwarmDebugOptions"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFSwarmDebugOptions
{
	FScriptStruct_Engine_StaticRegisterNativesFSwarmDebugOptions()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("SwarmDebugOptions")),new UScriptStruct::TCppStructOps<FSwarmDebugOptions>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFSwarmDebugOptions;
	UScriptStruct* Z_Construct_UScriptStruct_FSwarmDebugOptions()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FSwarmDebugOptions_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("SwarmDebugOptions"), sizeof(FSwarmDebugOptions), Get_Z_Construct_UScriptStruct_FSwarmDebugOptions_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Debug options for Swarm" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FSwarmDebugOptions>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bInitialized_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewProp_bInitialized_SetBit = [](void* Obj){ ((FSwarmDebugOptions*)Obj)->bInitialized = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bInitialized = { UE4CodeGen_Private::EPropertyClass::Bool, "bInitialized", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FSwarmDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bInitialized_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bInitialized_MetaData, ARRAY_COUNT(NewProp_bInitialized_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bForceContentExport_MetaData[] = {
				{ "Category", "SwarmDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Swarm will force content to re-export rather than using the cached version.\nIf false, Swarm will attempt to use the cached version." },
			};
#endif
			auto NewProp_bForceContentExport_SetBit = [](void* Obj){ ((FSwarmDebugOptions*)Obj)->bForceContentExport = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bForceContentExport = { UE4CodeGen_Private::EPropertyClass::Bool, "bForceContentExport", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FSwarmDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bForceContentExport_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bForceContentExport_MetaData, ARRAY_COUNT(NewProp_bForceContentExport_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bDistributionEnabled_MetaData[] = {
				{ "Category", "SwarmDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Swarm will distribute jobs.\nIf false, only the local machine will execute the jobs." },
			};
#endif
			auto NewProp_bDistributionEnabled_SetBit = [](void* Obj){ ((FSwarmDebugOptions*)Obj)->bDistributionEnabled = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bDistributionEnabled = { UE4CodeGen_Private::EPropertyClass::Bool, "bDistributionEnabled", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FSwarmDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bDistributionEnabled_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bDistributionEnabled_MetaData, ARRAY_COUNT(NewProp_bDistributionEnabled_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bInitialized,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bForceContentExport,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bDistributionEnabled,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"SwarmDebugOptions",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FSwarmDebugOptions),
				alignof(FSwarmDebugOptions),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSwarmDebugOptions_CRC() { return 3245846356U; }
class UScriptStruct* FLightmassDebugOptions::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLightmassDebugOptions_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLightmassDebugOptions, Z_Construct_UPackage__Script_Engine(), TEXT("LightmassDebugOptions"), sizeof(FLightmassDebugOptions), Get_Z_Construct_UScriptStruct_FLightmassDebugOptions_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLightmassDebugOptions(FLightmassDebugOptions::StaticStruct, TEXT("/Script/Engine"), TEXT("LightmassDebugOptions"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLightmassDebugOptions
{
	FScriptStruct_Engine_StaticRegisterNativesFLightmassDebugOptions()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LightmassDebugOptions")),new UScriptStruct::TCppStructOps<FLightmassDebugOptions>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLightmassDebugOptions;
	UScriptStruct* Z_Construct_UScriptStruct_FLightmassDebugOptions()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLightmassDebugOptions_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LightmassDebugOptions"), sizeof(FLightmassDebugOptions), Get_Z_Construct_UScriptStruct_FLightmassDebugOptions_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Debug options for Lightmass" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLightmassDebugOptions>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ExecutionTimeDivisor_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The amount of time that will be count as full red when bColorByExecutionTime is enabled" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ExecutionTimeDivisor = { UE4CodeGen_Private::EPropertyClass::Float, "ExecutionTimeDivisor", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassDebugOptions, ExecutionTimeDivisor), METADATA_PARAMS(NewProp_ExecutionTimeDivisor_MetaData, ARRAY_COUNT(NewProp_ExecutionTimeDivisor_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bColorByExecutionTime_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Lightmass will overwrite lightmap data with a shade of red relating to\nhow long it took to calculate the mapping (Red = Time / ExecutionTimeDivisor)" },
			};
#endif
			auto NewProp_bColorByExecutionTime_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bColorByExecutionTime = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bColorByExecutionTime = { UE4CodeGen_Private::EPropertyClass::Bool, "bColorByExecutionTime", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bColorByExecutionTime_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bColorByExecutionTime_MetaData, ARRAY_COUNT(NewProp_bColorByExecutionTime_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bColorBordersGreen_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, a green border will be placed around the edges of mappings" },
			};
#endif
			auto NewProp_bColorBordersGreen_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bColorBordersGreen = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bColorBordersGreen = { UE4CodeGen_Private::EPropertyClass::Bool, "bColorBordersGreen", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bColorBordersGreen_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bColorBordersGreen_MetaData, ARRAY_COUNT(NewProp_bColorBordersGreen_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseRandomColors_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, color lightmaps a random color" },
			};
#endif
			auto NewProp_bUseRandomColors_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bUseRandomColors = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseRandomColors = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseRandomColors", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseRandomColors_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseRandomColors_MetaData, ARRAY_COUNT(NewProp_bUseRandomColors_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bOnlyCalcDebugTexelMappings_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, only the mapping containing a debug texel will be calculated, all others\nwill be set to white" },
			};
#endif
			auto NewProp_bOnlyCalcDebugTexelMappings_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bOnlyCalcDebugTexelMappings = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bOnlyCalcDebugTexelMappings = { UE4CodeGen_Private::EPropertyClass::Bool, "bOnlyCalcDebugTexelMappings", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bOnlyCalcDebugTexelMappings_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bOnlyCalcDebugTexelMappings_MetaData, ARRAY_COUNT(NewProp_bOnlyCalcDebugTexelMappings_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bDebugPaddings_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, will fill padding of mappings with a color rather than the sampled edges.\nMeans nothing if bPadMappings is not enabled..." },
			};
#endif
			auto NewProp_bDebugPaddings_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bDebugPaddings = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bDebugPaddings = { UE4CodeGen_Private::EPropertyClass::Bool, "bDebugPaddings", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bDebugPaddings_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bDebugPaddings_MetaData, ARRAY_COUNT(NewProp_bDebugPaddings_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bPadMappings_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Lightmass will pad the calculated mappings to reduce/eliminate seams." },
			};
#endif
			auto NewProp_bPadMappings_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bPadMappings = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bPadMappings = { UE4CodeGen_Private::EPropertyClass::Bool, "bPadMappings", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bPadMappings_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bPadMappings_MetaData, ARRAY_COUNT(NewProp_bPadMappings_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bDebugMaterials_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Lightmass will write out BMPs for each generated material property\nsample to <GAME>\\ScreenShots\\Materials." },
			};
#endif
			auto NewProp_bDebugMaterials_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bDebugMaterials = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bDebugMaterials = { UE4CodeGen_Private::EPropertyClass::Bool, "bDebugMaterials", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bDebugMaterials_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bDebugMaterials_MetaData, ARRAY_COUNT(NewProp_bDebugMaterials_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bDumpBinaryFiles_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, the generate coefficients will be dumped to binary files." },
			};
#endif
			auto NewProp_bDumpBinaryFiles_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bDumpBinaryFiles = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bDumpBinaryFiles = { UE4CodeGen_Private::EPropertyClass::Bool, "bDumpBinaryFiles", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bDumpBinaryFiles_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bDumpBinaryFiles_MetaData, ARRAY_COUNT(NewProp_bDumpBinaryFiles_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bSortMappings_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Lightmass will sort mappings by texel cost." },
			};
#endif
			auto NewProp_bSortMappings_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bSortMappings = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bSortMappings = { UE4CodeGen_Private::EPropertyClass::Bool, "bSortMappings", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bSortMappings_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bSortMappings_MetaData, ARRAY_COUNT(NewProp_bSortMappings_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bImmediateProcessMappings_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Lightmass will process appropriate mappings as they are imported.\nNOTE: Requires ImmediateMode be enabled to actually work." },
			};
#endif
			auto NewProp_bImmediateProcessMappings_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bImmediateProcessMappings = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bImmediateProcessMappings = { UE4CodeGen_Private::EPropertyClass::Bool, "bImmediateProcessMappings", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bImmediateProcessMappings_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bImmediateProcessMappings_MetaData, ARRAY_COUNT(NewProp_bImmediateProcessMappings_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseImmediateImport_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, Lightmass will import mappings immediately as they complete.\nIt will not process them, however." },
			};
#endif
			auto NewProp_bUseImmediateImport_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bUseImmediateImport = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseImmediateImport = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseImmediateImport", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseImmediateImport_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseImmediateImport_MetaData, ARRAY_COUNT(NewProp_bUseImmediateImport_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_CoplanarTolerance_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The tolerance level used when gathering BSP surfaces." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_CoplanarTolerance = { UE4CodeGen_Private::EPropertyClass::Float, "CoplanarTolerance", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassDebugOptions, CoplanarTolerance), METADATA_PARAMS(NewProp_CoplanarTolerance_MetaData, ARRAY_COUNT(NewProp_CoplanarTolerance_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bGatherBSPSurfacesAcrossComponents_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, BSP surfaces split across model components are joined into 1 mapping" },
			};
#endif
			auto NewProp_bGatherBSPSurfacesAcrossComponents_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bGatherBSPSurfacesAcrossComponents = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bGatherBSPSurfacesAcrossComponents = { UE4CodeGen_Private::EPropertyClass::Bool, "bGatherBSPSurfacesAcrossComponents", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bGatherBSPSurfacesAcrossComponents_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bGatherBSPSurfacesAcrossComponents_MetaData, ARRAY_COUNT(NewProp_bGatherBSPSurfacesAcrossComponents_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bStatsEnabled_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, all participating Lightmass agents will report back detailed stats to the log." },
			};
#endif
			auto NewProp_bStatsEnabled_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bStatsEnabled = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bStatsEnabled = { UE4CodeGen_Private::EPropertyClass::Bool, "bStatsEnabled", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bStatsEnabled_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bStatsEnabled_MetaData, ARRAY_COUNT(NewProp_bStatsEnabled_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bDebugMode_MetaData[] = {
				{ "Category", "LightmassDebugOptions" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If false, UnrealLightmass.exe is launched automatically (default)\nIf true, it must be launched manually (e.g. through a debugger) with the -debug command line parameter." },
			};
#endif
			auto NewProp_bDebugMode_SetBit = [](void* Obj){ ((FLightmassDebugOptions*)Obj)->bDebugMode = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bDebugMode = { UE4CodeGen_Private::EPropertyClass::Bool, "bDebugMode", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassDebugOptions), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bDebugMode_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bDebugMode_MetaData, ARRAY_COUNT(NewProp_bDebugMode_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ExecutionTimeDivisor,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bColorByExecutionTime,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bColorBordersGreen,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseRandomColors,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bOnlyCalcDebugTexelMappings,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bDebugPaddings,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bPadMappings,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bDebugMaterials,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bDumpBinaryFiles,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bSortMappings,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bImmediateProcessMappings,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseImmediateImport,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_CoplanarTolerance,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bGatherBSPSurfacesAcrossComponents,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bStatsEnabled,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bDebugMode,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LightmassDebugOptions",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLightmassDebugOptions),
				alignof(FLightmassDebugOptions),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightmassDebugOptions_CRC() { return 2039808605U; }
class UScriptStruct* FLightmassPrimitiveSettings::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLightmassPrimitiveSettings_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLightmassPrimitiveSettings, Z_Construct_UPackage__Script_Engine(), TEXT("LightmassPrimitiveSettings"), sizeof(FLightmassPrimitiveSettings), Get_Z_Construct_UScriptStruct_FLightmassPrimitiveSettings_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLightmassPrimitiveSettings(FLightmassPrimitiveSettings::StaticStruct, TEXT("/Script/Engine"), TEXT("LightmassPrimitiveSettings"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLightmassPrimitiveSettings
{
	FScriptStruct_Engine_StaticRegisterNativesFLightmassPrimitiveSettings()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LightmassPrimitiveSettings")),new UScriptStruct::TCppStructOps<FLightmassPrimitiveSettings>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLightmassPrimitiveSettings;
	UScriptStruct* Z_Construct_UScriptStruct_FLightmassPrimitiveSettings()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLightmassPrimitiveSettings_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LightmassPrimitiveSettings"), sizeof(FLightmassPrimitiveSettings), Get_Z_Construct_UScriptStruct_FLightmassPrimitiveSettings_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Per-object settings for Lightmass" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLightmassPrimitiveSettings>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_FullyOccludedSamplesFraction_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Fraction of samples taken that must be occluded in order to reach full occlusion." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_FullyOccludedSamplesFraction = { UE4CodeGen_Private::EPropertyClass::Float, "FullyOccludedSamplesFraction", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassPrimitiveSettings, FullyOccludedSamplesFraction), METADATA_PARAMS(NewProp_FullyOccludedSamplesFraction_MetaData, ARRAY_COUNT(NewProp_FullyOccludedSamplesFraction_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_DiffuseBoost_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Scales the diffuse contribution of all materials applied to this object." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_DiffuseBoost = { UE4CodeGen_Private::EPropertyClass::Float, "DiffuseBoost", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassPrimitiveSettings, DiffuseBoost), METADATA_PARAMS(NewProp_DiffuseBoost_MetaData, ARRAY_COUNT(NewProp_DiffuseBoost_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EmissiveBoost_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Scales the emissive contribution of all materials applied to this object." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_EmissiveBoost = { UE4CodeGen_Private::EPropertyClass::Float, "EmissiveBoost", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassPrimitiveSettings, EmissiveBoost), METADATA_PARAMS(NewProp_EmissiveBoost_MetaData, ARRAY_COUNT(NewProp_EmissiveBoost_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EmissiveLightExplicitInfluenceRadius_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Direct lighting influence radius.\nThe default is 0, which means the influence radius should be automatically generated based on the emissive light brightness.\nValues greater than 0 override the automatic method." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_EmissiveLightExplicitInfluenceRadius = { UE4CodeGen_Private::EPropertyClass::Float, "EmissiveLightExplicitInfluenceRadius", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FLightmassPrimitiveSettings, EmissiveLightExplicitInfluenceRadius), METADATA_PARAMS(NewProp_EmissiveLightExplicitInfluenceRadius_MetaData, ARRAY_COUNT(NewProp_EmissiveLightExplicitInfluenceRadius_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EmissiveLightFalloffExponent_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Direct lighting falloff exponent for mesh area lights created from emissive areas on this primitive." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_EmissiveLightFalloffExponent = { UE4CodeGen_Private::EPropertyClass::Float, "EmissiveLightFalloffExponent", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FLightmassPrimitiveSettings, EmissiveLightFalloffExponent), METADATA_PARAMS(NewProp_EmissiveLightFalloffExponent_MetaData, ARRAY_COUNT(NewProp_EmissiveLightFalloffExponent_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseVertexNormalForHemisphereGather_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Typically the triangle normal is used for hemisphere gathering which prevents incorrect self-shadowing from artist-tweaked vertex normals.\nHowever in the case of foliage whose vertex normal has been setup to match the underlying terrain, gathering in the direction of the vertex normal is desired." },
			};
#endif
			auto NewProp_bUseVertexNormalForHemisphereGather_SetBit = [](void* Obj){ ((FLightmassPrimitiveSettings*)Obj)->bUseVertexNormalForHemisphereGather = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseVertexNormalForHemisphereGather = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseVertexNormalForHemisphereGather", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassPrimitiveSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseVertexNormalForHemisphereGather_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseVertexNormalForHemisphereGather_MetaData, ARRAY_COUNT(NewProp_bUseVertexNormalForHemisphereGather_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseEmissiveForStaticLighting_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, allow using the emissive for static lighting." },
			};
#endif
			auto NewProp_bUseEmissiveForStaticLighting_SetBit = [](void* Obj){ ((FLightmassPrimitiveSettings*)Obj)->bUseEmissiveForStaticLighting = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseEmissiveForStaticLighting = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseEmissiveForStaticLighting", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassPrimitiveSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseEmissiveForStaticLighting_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseEmissiveForStaticLighting_MetaData, ARRAY_COUNT(NewProp_bUseEmissiveForStaticLighting_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bShadowIndirectOnly_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, this object will only shadow indirect lighting." },
			};
#endif
			auto NewProp_bShadowIndirectOnly_SetBit = [](void* Obj){ ((FLightmassPrimitiveSettings*)Obj)->bShadowIndirectOnly = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bShadowIndirectOnly = { UE4CodeGen_Private::EPropertyClass::Bool, "bShadowIndirectOnly", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassPrimitiveSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bShadowIndirectOnly_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bShadowIndirectOnly_MetaData, ARRAY_COUNT(NewProp_bShadowIndirectOnly_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseTwoSidedLighting_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "If true, this object will be lit as if it receives light from both sides of its polygons." },
			};
#endif
			auto NewProp_bUseTwoSidedLighting_SetBit = [](void* Obj){ ((FLightmassPrimitiveSettings*)Obj)->bUseTwoSidedLighting = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseTwoSidedLighting = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseTwoSidedLighting", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightmassPrimitiveSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseTwoSidedLighting_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseTwoSidedLighting_MetaData, ARRAY_COUNT(NewProp_bUseTwoSidedLighting_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_FullyOccludedSamplesFraction,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_DiffuseBoost,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EmissiveBoost,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EmissiveLightExplicitInfluenceRadius,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EmissiveLightFalloffExponent,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseVertexNormalForHemisphereGather,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseEmissiveForStaticLighting,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bShadowIndirectOnly,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseTwoSidedLighting,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LightmassPrimitiveSettings",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLightmassPrimitiveSettings),
				alignof(FLightmassPrimitiveSettings),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightmassPrimitiveSettings_CRC() { return 2242098872U; }
class UScriptStruct* FLightmassDirectionalLightSettings::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings, Z_Construct_UPackage__Script_Engine(), TEXT("LightmassDirectionalLightSettings"), sizeof(FLightmassDirectionalLightSettings), Get_Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLightmassDirectionalLightSettings(FLightmassDirectionalLightSettings::StaticStruct, TEXT("/Script/Engine"), TEXT("LightmassDirectionalLightSettings"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLightmassDirectionalLightSettings
{
	FScriptStruct_Engine_StaticRegisterNativesFLightmassDirectionalLightSettings()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LightmassDirectionalLightSettings")),new UScriptStruct::TCppStructOps<FLightmassDirectionalLightSettings>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLightmassDirectionalLightSettings;
	UScriptStruct* Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LightmassDirectionalLightSettings"), sizeof(FLightmassDirectionalLightSettings), Get_Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Directional light settings for Lightmass" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLightmassDirectionalLightSettings>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LightSourceAngle_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Angle that the directional light's emissive surface extends relative to a receiver, affects penumbra sizes." },
				{ "UIMax", "5" },
				{ "UIMin", ".0001" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_LightSourceAngle = { UE4CodeGen_Private::EPropertyClass::Float, "LightSourceAngle", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassDirectionalLightSettings, LightSourceAngle), METADATA_PARAMS(NewProp_LightSourceAngle_MetaData, ARRAY_COUNT(NewProp_LightSourceAngle_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LightSourceAngle,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				Z_Construct_UScriptStruct_FLightmassLightSettings,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LightmassDirectionalLightSettings",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLightmassDirectionalLightSettings),
				alignof(FLightmassDirectionalLightSettings),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightmassDirectionalLightSettings_CRC() { return 2001243145U; }
class UScriptStruct* FLightmassPointLightSettings::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLightmassPointLightSettings_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLightmassPointLightSettings, Z_Construct_UPackage__Script_Engine(), TEXT("LightmassPointLightSettings"), sizeof(FLightmassPointLightSettings), Get_Z_Construct_UScriptStruct_FLightmassPointLightSettings_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLightmassPointLightSettings(FLightmassPointLightSettings::StaticStruct, TEXT("/Script/Engine"), TEXT("LightmassPointLightSettings"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLightmassPointLightSettings
{
	FScriptStruct_Engine_StaticRegisterNativesFLightmassPointLightSettings()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LightmassPointLightSettings")),new UScriptStruct::TCppStructOps<FLightmassPointLightSettings>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLightmassPointLightSettings;
	UScriptStruct* Z_Construct_UScriptStruct_FLightmassPointLightSettings()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLightmassPointLightSettings_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LightmassPointLightSettings"), sizeof(FLightmassPointLightSettings), Get_Z_Construct_UScriptStruct_FLightmassPointLightSettings_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Point/spot settings for Lightmass" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLightmassPointLightSettings>(); };
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				Z_Construct_UScriptStruct_FLightmassLightSettings,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LightmassPointLightSettings",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLightmassPointLightSettings),
				alignof(FLightmassPointLightSettings),
				nullptr, 0,
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightmassPointLightSettings_CRC() { return 2087353164U; }
class UScriptStruct* FLightmassLightSettings::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLightmassLightSettings_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLightmassLightSettings, Z_Construct_UPackage__Script_Engine(), TEXT("LightmassLightSettings"), sizeof(FLightmassLightSettings), Get_Z_Construct_UScriptStruct_FLightmassLightSettings_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLightmassLightSettings(FLightmassLightSettings::StaticStruct, TEXT("/Script/Engine"), TEXT("LightmassLightSettings"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLightmassLightSettings
{
	FScriptStruct_Engine_StaticRegisterNativesFLightmassLightSettings()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LightmassLightSettings")),new UScriptStruct::TCppStructOps<FLightmassLightSettings>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLightmassLightSettings;
	UScriptStruct* Z_Construct_UScriptStruct_FLightmassLightSettings()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLightmassLightSettings_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LightmassLightSettings"), sizeof(FLightmassLightSettings), Get_Z_Construct_UScriptStruct_FLightmassLightSettings_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Per-light settings for Lightmass" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLightmassLightSettings>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bUseAreaShadowsForStationaryLight_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Whether to use area shadows for stationary light precomputed shadowmaps.\nArea shadows get softer the further they are from shadow casters, but require higher lightmap resolution to get the same quality where the shadow is sharp." },
			};
#endif
			auto NewProp_bUseAreaShadowsForStationaryLight_SetBit = [](void* Obj){ ((FLightmassLightSettings*)Obj)->bUseAreaShadowsForStationaryLight = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bUseAreaShadowsForStationaryLight = { UE4CodeGen_Private::EPropertyClass::Bool, "bUseAreaShadowsForStationaryLight", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, sizeof(bool), UE4CodeGen_Private::ENativeBool::Native, sizeof(FLightmassLightSettings), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bUseAreaShadowsForStationaryLight_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bUseAreaShadowsForStationaryLight_MetaData, ARRAY_COUNT(NewProp_bUseAreaShadowsForStationaryLight_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ShadowExponent_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Controls the falloff of shadow penumbras" },
				{ "UIMax", "4.0" },
				{ "UIMin", "0.1" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ShadowExponent = { UE4CodeGen_Private::EPropertyClass::Float, "ShadowExponent", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassLightSettings, ShadowExponent), METADATA_PARAMS(NewProp_ShadowExponent_MetaData, ARRAY_COUNT(NewProp_ShadowExponent_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_IndirectLightingSaturation_MetaData[] = {
				{ "Category", "Lightmass" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "0 will be completely desaturated, 1 will be unchanged" },
				{ "UIMax", "4.0" },
				{ "UIMin", "0.0" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_IndirectLightingSaturation = { UE4CodeGen_Private::EPropertyClass::Float, "IndirectLightingSaturation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FLightmassLightSettings, IndirectLightingSaturation), METADATA_PARAMS(NewProp_IndirectLightingSaturation_MetaData, ARRAY_COUNT(NewProp_IndirectLightingSaturation_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bUseAreaShadowsForStationaryLight,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ShadowExponent,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_IndirectLightingSaturation,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LightmassLightSettings",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLightmassLightSettings),
				alignof(FLightmassLightSettings),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightmassLightSettings_CRC() { return 3373060556U; }
class UScriptStruct* FLocalizedSubtitle::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLocalizedSubtitle_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLocalizedSubtitle, Z_Construct_UPackage__Script_Engine(), TEXT("LocalizedSubtitle"), sizeof(FLocalizedSubtitle), Get_Z_Construct_UScriptStruct_FLocalizedSubtitle_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLocalizedSubtitle(FLocalizedSubtitle::StaticStruct, TEXT("/Script/Engine"), TEXT("LocalizedSubtitle"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLocalizedSubtitle
{
	FScriptStruct_Engine_StaticRegisterNativesFLocalizedSubtitle()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LocalizedSubtitle")),new UScriptStruct::TCppStructOps<FLocalizedSubtitle>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLocalizedSubtitle;
	UScriptStruct* Z_Construct_UScriptStruct_FLocalizedSubtitle()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLocalizedSubtitle_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LocalizedSubtitle"), sizeof(FLocalizedSubtitle), Get_Z_Construct_UScriptStruct_FLocalizedSubtitle_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "A subtitle localized to a specific language." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLocalizedSubtitle>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bSingleLine_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "true if the subtitles should be displayed one line at a time." },
			};
#endif
			auto NewProp_bSingleLine_SetBit = [](void* Obj){ ((FLocalizedSubtitle*)Obj)->bSingleLine = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bSingleLine = { UE4CodeGen_Private::EPropertyClass::Bool, "bSingleLine", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLocalizedSubtitle), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bSingleLine_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bSingleLine_MetaData, ARRAY_COUNT(NewProp_bSingleLine_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bManualWordWrap_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "true if the subtitles have been split manually." },
			};
#endif
			auto NewProp_bManualWordWrap_SetBit = [](void* Obj){ ((FLocalizedSubtitle*)Obj)->bManualWordWrap = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bManualWordWrap = { UE4CodeGen_Private::EPropertyClass::Bool, "bManualWordWrap", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLocalizedSubtitle), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bManualWordWrap_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bManualWordWrap_MetaData, ARRAY_COUNT(NewProp_bManualWordWrap_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bMature_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "true if this sound is considered to contain mature content." },
			};
#endif
			auto NewProp_bMature_SetBit = [](void* Obj){ ((FLocalizedSubtitle*)Obj)->bMature = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bMature = { UE4CodeGen_Private::EPropertyClass::Bool, "bMature", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLocalizedSubtitle), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bMature_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bMature_MetaData, ARRAY_COUNT(NewProp_bMature_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Subtitles_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Subtitle cues.  If empty, use SoundNodeWave's SpokenText as the subtitle.  Will often be empty,\nas the contents of the subtitle is commonly identical to what is spoken." },
			};
#endif
			static const UE4CodeGen_Private::FArrayPropertyParams NewProp_Subtitles = { UE4CodeGen_Private::EPropertyClass::Array, "Subtitles", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FLocalizedSubtitle, Subtitles), METADATA_PARAMS(NewProp_Subtitles_MetaData, ARRAY_COUNT(NewProp_Subtitles_MetaData)) };
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Subtitles_Inner = { UE4CodeGen_Private::EPropertyClass::Struct, "Subtitles", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, Z_Construct_UScriptStruct_FSubtitleCue, METADATA_PARAMS(nullptr, 0) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LanguageExt_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The 3-letter language for this subtitle" },
			};
#endif
			static const UE4CodeGen_Private::FStrPropertyParams NewProp_LanguageExt = { UE4CodeGen_Private::EPropertyClass::Str, "LanguageExt", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FLocalizedSubtitle, LanguageExt), METADATA_PARAMS(NewProp_LanguageExt_MetaData, ARRAY_COUNT(NewProp_LanguageExt_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bSingleLine,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bManualWordWrap,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bMature,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Subtitles,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Subtitles_Inner,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LanguageExt,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LocalizedSubtitle",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLocalizedSubtitle),
				alignof(FLocalizedSubtitle),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLocalizedSubtitle_CRC() { return 3159801924U; }
class UScriptStruct* FSubtitleCue::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FSubtitleCue_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FSubtitleCue, Z_Construct_UPackage__Script_Engine(), TEXT("SubtitleCue"), sizeof(FSubtitleCue), Get_Z_Construct_UScriptStruct_FSubtitleCue_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FSubtitleCue(FSubtitleCue::StaticStruct, TEXT("/Script/Engine"), TEXT("SubtitleCue"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFSubtitleCue
{
	FScriptStruct_Engine_StaticRegisterNativesFSubtitleCue()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("SubtitleCue")),new UScriptStruct::TCppStructOps<FSubtitleCue>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFSubtitleCue;
	UScriptStruct* Z_Construct_UScriptStruct_FSubtitleCue()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FSubtitleCue_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("SubtitleCue"), sizeof(FSubtitleCue), Get_Z_Construct_UScriptStruct_FSubtitleCue_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "A line of subtitle text and the time at which it should be displayed." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FSubtitleCue>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Time_MetaData[] = {
				{ "Category", "SubtitleCue" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The time at which the subtitle is to be displayed, in seconds relative to the beginning of the line." },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_Time = { UE4CodeGen_Private::EPropertyClass::Float, "Time", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FSubtitleCue, Time), METADATA_PARAMS(NewProp_Time_MetaData, ARRAY_COUNT(NewProp_Time_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Text_MetaData[] = {
				{ "Category", "SubtitleCue" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "The text to appear in the subtitle." },
			};
#endif
			static const UE4CodeGen_Private::FTextPropertyParams NewProp_Text = { UE4CodeGen_Private::EPropertyClass::Text, "Text", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FSubtitleCue, Text), METADATA_PARAMS(NewProp_Text_MetaData, ARRAY_COUNT(NewProp_Text_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Time,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Text,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"SubtitleCue",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FSubtitleCue),
				alignof(FSubtitleCue),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FSubtitleCue_CRC() { return 3102867160U; }
class UScriptStruct* FBasedPosition::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FBasedPosition_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBasedPosition, Z_Construct_UPackage__Script_Engine(), TEXT("BasedPosition"), sizeof(FBasedPosition), Get_Z_Construct_UScriptStruct_FBasedPosition_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBasedPosition(FBasedPosition::StaticStruct, TEXT("/Script/Engine"), TEXT("BasedPosition"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFBasedPosition
{
	FScriptStruct_Engine_StaticRegisterNativesFBasedPosition()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BasedPosition")),new UScriptStruct::TCppStructOps<FBasedPosition>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFBasedPosition;
	UScriptStruct* Z_Construct_UScriptStruct_FBasedPosition()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FBasedPosition_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BasedPosition"), sizeof(FBasedPosition), Get_Z_Construct_UScriptStruct_FBasedPosition_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Struct for handling positions relative to a base actor, which is potentially moving" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FBasedPosition>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_CachedTransPosition_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_CachedTransPosition = { UE4CodeGen_Private::EPropertyClass::Struct, "CachedTransPosition", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FBasedPosition, CachedTransPosition), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_CachedTransPosition_MetaData, ARRAY_COUNT(NewProp_CachedTransPosition_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_CachedBaseRotation_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_CachedBaseRotation = { UE4CodeGen_Private::EPropertyClass::Struct, "CachedBaseRotation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FBasedPosition, CachedBaseRotation), Z_Construct_UScriptStruct_FRotator, METADATA_PARAMS(NewProp_CachedBaseRotation_MetaData, ARRAY_COUNT(NewProp_CachedBaseRotation_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_CachedBaseLocation_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_CachedBaseLocation = { UE4CodeGen_Private::EPropertyClass::Struct, "CachedBaseLocation", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FBasedPosition, CachedBaseLocation), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_CachedBaseLocation_MetaData, ARRAY_COUNT(NewProp_CachedBaseLocation_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Position_MetaData[] = {
				{ "Category", "BasedPosition" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Position = { UE4CodeGen_Private::EPropertyClass::Struct, "Position", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FBasedPosition, Position), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_Position_MetaData, ARRAY_COUNT(NewProp_Position_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Base_MetaData[] = {
				{ "Category", "BasedPosition" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_Base = { UE4CodeGen_Private::EPropertyClass::Object, "Base", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FBasedPosition, Base), Z_Construct_UClass_AActor_NoRegister, METADATA_PARAMS(NewProp_Base_MetaData, ARRAY_COUNT(NewProp_Base_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_CachedTransPosition,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_CachedBaseRotation,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_CachedBaseLocation,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Position,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Base,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"BasedPosition",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FBasedPosition),
				alignof(FBasedPosition),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBasedPosition_CRC() { return 2627213718U; }
class UScriptStruct* FFractureEffect::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FFractureEffect_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FFractureEffect, Z_Construct_UPackage__Script_Engine(), TEXT("FractureEffect"), sizeof(FFractureEffect), Get_Z_Construct_UScriptStruct_FFractureEffect_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FFractureEffect(FFractureEffect::StaticStruct, TEXT("/Script/Engine"), TEXT("FractureEffect"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFFractureEffect
{
	FScriptStruct_Engine_StaticRegisterNativesFFractureEffect()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("FractureEffect")),new UScriptStruct::TCppStructOps<FFractureEffect>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFFractureEffect;
	UScriptStruct* Z_Construct_UScriptStruct_FFractureEffect()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FFractureEffect_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FractureEffect"), sizeof(FFractureEffect), Get_Z_Construct_UScriptStruct_FFractureEffect_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Struct used to hold effects for destructible damage events" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FFractureEffect>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Sound_MetaData[] = {
				{ "Category", "FractureEffect" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Sound cue to play at fracture location." },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_Sound = { UE4CodeGen_Private::EPropertyClass::Object, "Sound", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FFractureEffect, Sound), Z_Construct_UClass_USoundBase_NoRegister, METADATA_PARAMS(NewProp_Sound_MetaData, ARRAY_COUNT(NewProp_Sound_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ParticleSystem_MetaData[] = {
				{ "Category", "FractureEffect" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Particle system effect to play at fracture location." },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_ParticleSystem = { UE4CodeGen_Private::EPropertyClass::Object, "ParticleSystem", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000005, 1, nullptr, STRUCT_OFFSET(FFractureEffect, ParticleSystem), Z_Construct_UClass_UParticleSystem_NoRegister, METADATA_PARAMS(NewProp_ParticleSystem_MetaData, ARRAY_COUNT(NewProp_ParticleSystem_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Sound,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ParticleSystem,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"FractureEffect",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FFractureEffect),
				alignof(FFractureEffect),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFractureEffect_CRC() { return 2467190024U; }
class UScriptStruct* FCollisionImpactData::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FCollisionImpactData_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FCollisionImpactData, Z_Construct_UPackage__Script_Engine(), TEXT("CollisionImpactData"), sizeof(FCollisionImpactData), Get_Z_Construct_UScriptStruct_FCollisionImpactData_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FCollisionImpactData(FCollisionImpactData::StaticStruct, TEXT("/Script/Engine"), TEXT("CollisionImpactData"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFCollisionImpactData
{
	FScriptStruct_Engine_StaticRegisterNativesFCollisionImpactData()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("CollisionImpactData")),new UScriptStruct::TCppStructOps<FCollisionImpactData>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFCollisionImpactData;
	UScriptStruct* Z_Construct_UScriptStruct_FCollisionImpactData()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FCollisionImpactData_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("CollisionImpactData"), sizeof(FCollisionImpactData), Get_Z_Construct_UScriptStruct_FCollisionImpactData_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Information about an overall collision, including contacts." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FCollisionImpactData>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_TotalFrictionImpulse_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "the total counterimpulse applied of the two objects sliding against each other" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_TotalFrictionImpulse = { UE4CodeGen_Private::EPropertyClass::Struct, "TotalFrictionImpulse", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FCollisionImpactData, TotalFrictionImpulse), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_TotalFrictionImpulse_MetaData, ARRAY_COUNT(NewProp_TotalFrictionImpulse_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_TotalNormalImpulse_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "the total impulse applied as the two objects push against each other" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_TotalNormalImpulse = { UE4CodeGen_Private::EPropertyClass::Struct, "TotalNormalImpulse", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FCollisionImpactData, TotalNormalImpulse), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_TotalNormalImpulse_MetaData, ARRAY_COUNT(NewProp_TotalNormalImpulse_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ContactInfos_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "all the contact points in the collision" },
			};
#endif
			static const UE4CodeGen_Private::FArrayPropertyParams NewProp_ContactInfos = { UE4CodeGen_Private::EPropertyClass::Array, "ContactInfos", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FCollisionImpactData, ContactInfos), METADATA_PARAMS(NewProp_ContactInfos_MetaData, ARRAY_COUNT(NewProp_ContactInfos_MetaData)) };
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ContactInfos_Inner = { UE4CodeGen_Private::EPropertyClass::Struct, "ContactInfos", RF_Public|RF_Transient|RF_MarkAsNative, 0x0000000000000000, 1, nullptr, 0, Z_Construct_UScriptStruct_FRigidBodyContactInfo, METADATA_PARAMS(nullptr, 0) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_TotalFrictionImpulse,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_TotalNormalImpulse,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ContactInfos,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ContactInfos_Inner,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"CollisionImpactData",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FCollisionImpactData),
				alignof(FCollisionImpactData),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FCollisionImpactData_CRC() { return 352493287U; }
class UScriptStruct* FRigidBodyContactInfo::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRigidBodyContactInfo_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRigidBodyContactInfo, Z_Construct_UPackage__Script_Engine(), TEXT("RigidBodyContactInfo"), sizeof(FRigidBodyContactInfo), Get_Z_Construct_UScriptStruct_FRigidBodyContactInfo_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRigidBodyContactInfo(FRigidBodyContactInfo::StaticStruct, TEXT("/Script/Engine"), TEXT("RigidBodyContactInfo"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRigidBodyContactInfo
{
	FScriptStruct_Engine_StaticRegisterNativesFRigidBodyContactInfo()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RigidBodyContactInfo")),new UScriptStruct::TCppStructOps<FRigidBodyContactInfo>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRigidBodyContactInfo;
	UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyContactInfo()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRigidBodyContactInfo_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RigidBodyContactInfo"), sizeof(FRigidBodyContactInfo), Get_Z_Construct_UScriptStruct_FRigidBodyContactInfo_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Information about one contact between a pair of rigid bodies." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRigidBodyContactInfo>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_PhysMaterial_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FObjectPropertyParams NewProp_PhysMaterial = { UE4CodeGen_Private::EPropertyClass::Object, "PhysMaterial", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, CPP_ARRAY_DIM(PhysMaterial, FRigidBodyContactInfo), nullptr, STRUCT_OFFSET(FRigidBodyContactInfo, PhysMaterial), Z_Construct_UClass_UPhysicalMaterial_NoRegister, METADATA_PARAMS(NewProp_PhysMaterial_MetaData, ARRAY_COUNT(NewProp_PhysMaterial_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ContactPenetration_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_ContactPenetration = { UE4CodeGen_Private::EPropertyClass::Float, "ContactPenetration", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyContactInfo, ContactPenetration), METADATA_PARAMS(NewProp_ContactPenetration_MetaData, ARRAY_COUNT(NewProp_ContactPenetration_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ContactNormal_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ContactNormal = { UE4CodeGen_Private::EPropertyClass::Struct, "ContactNormal", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyContactInfo, ContactNormal), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_ContactNormal_MetaData, ARRAY_COUNT(NewProp_ContactNormal_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_ContactPosition_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_ContactPosition = { UE4CodeGen_Private::EPropertyClass::Struct, "ContactPosition", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyContactInfo, ContactPosition), Z_Construct_UScriptStruct_FVector, METADATA_PARAMS(NewProp_ContactPosition_MetaData, ARRAY_COUNT(NewProp_ContactPosition_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_PhysMaterial,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ContactPenetration,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ContactNormal,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_ContactPosition,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RigidBodyContactInfo",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FRigidBodyContactInfo),
				alignof(FRigidBodyContactInfo),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRigidBodyContactInfo_CRC() { return 2115242633U; }
class UScriptStruct* FRigidBodyErrorCorrection::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRigidBodyErrorCorrection_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRigidBodyErrorCorrection, Z_Construct_UPackage__Script_Engine(), TEXT("RigidBodyErrorCorrection"), sizeof(FRigidBodyErrorCorrection), Get_Z_Construct_UScriptStruct_FRigidBodyErrorCorrection_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRigidBodyErrorCorrection(FRigidBodyErrorCorrection::StaticStruct, TEXT("/Script/Engine"), TEXT("RigidBodyErrorCorrection"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRigidBodyErrorCorrection
{
	FScriptStruct_Engine_StaticRegisterNativesFRigidBodyErrorCorrection()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RigidBodyErrorCorrection")),new UScriptStruct::TCppStructOps<FRigidBodyErrorCorrection>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRigidBodyErrorCorrection;
	UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyErrorCorrection()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRigidBodyErrorCorrection_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RigidBodyErrorCorrection"), sizeof(FRigidBodyErrorCorrection), Get_Z_Construct_UScriptStruct_FRigidBodyErrorCorrection_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Rigid body error correction data" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRigidBodyErrorCorrection>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_BodySpeedThresholdSq_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "min squared body speed to perform velocity adjustment" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_BodySpeedThresholdSq = { UE4CodeGen_Private::EPropertyClass::Float, "BodySpeedThresholdSq", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, BodySpeedThresholdSq), METADATA_PARAMS(NewProp_BodySpeedThresholdSq_MetaData, ARRAY_COUNT(NewProp_BodySpeedThresholdSq_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AngularRecipFixTime_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "inverted duration after which angular velocity adjustment will fix error" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_AngularRecipFixTime = { UE4CodeGen_Private::EPropertyClass::Float, "AngularRecipFixTime", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, AngularRecipFixTime), METADATA_PARAMS(NewProp_AngularRecipFixTime_MetaData, ARRAY_COUNT(NewProp_AngularRecipFixTime_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AngularInterpAlpha_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "strength of snapping to desired angular velocity" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_AngularInterpAlpha = { UE4CodeGen_Private::EPropertyClass::Float, "AngularInterpAlpha", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, AngularInterpAlpha), METADATA_PARAMS(NewProp_AngularInterpAlpha_MetaData, ARRAY_COUNT(NewProp_AngularInterpAlpha_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AngularDeltaThreshold_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "max squared angle difference (in radians) to perform velocity adjustment" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_AngularDeltaThreshold = { UE4CodeGen_Private::EPropertyClass::Float, "AngularDeltaThreshold", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, AngularDeltaThreshold), METADATA_PARAMS(NewProp_AngularDeltaThreshold_MetaData, ARRAY_COUNT(NewProp_AngularDeltaThreshold_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LinearRecipFixTime_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "inverted duration after which linear velocity adjustment will fix error" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_LinearRecipFixTime = { UE4CodeGen_Private::EPropertyClass::Float, "LinearRecipFixTime", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, LinearRecipFixTime), METADATA_PARAMS(NewProp_LinearRecipFixTime_MetaData, ARRAY_COUNT(NewProp_LinearRecipFixTime_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LinearInterpAlpha_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "strength of snapping to desired linear velocity" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_LinearInterpAlpha = { UE4CodeGen_Private::EPropertyClass::Float, "LinearInterpAlpha", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, LinearInterpAlpha), METADATA_PARAMS(NewProp_LinearInterpAlpha_MetaData, ARRAY_COUNT(NewProp_LinearInterpAlpha_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LinearDeltaThresholdSq_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "max squared position difference to perform velocity adjustment" },
			};
#endif
			static const UE4CodeGen_Private::FFloatPropertyParams NewProp_LinearDeltaThresholdSq = { UE4CodeGen_Private::EPropertyClass::Float, "LinearDeltaThresholdSq", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyErrorCorrection, LinearDeltaThresholdSq), METADATA_PARAMS(NewProp_LinearDeltaThresholdSq_MetaData, ARRAY_COUNT(NewProp_LinearDeltaThresholdSq_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_BodySpeedThresholdSq,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AngularRecipFixTime,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AngularInterpAlpha,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AngularDeltaThreshold,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LinearRecipFixTime,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LinearInterpAlpha,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LinearDeltaThresholdSq,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RigidBodyErrorCorrection",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FRigidBodyErrorCorrection),
				alignof(FRigidBodyErrorCorrection),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRigidBodyErrorCorrection_CRC() { return 1903386184U; }
class UScriptStruct* FRigidBodyState::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FRigidBodyState_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FRigidBodyState, Z_Construct_UPackage__Script_Engine(), TEXT("RigidBodyState"), sizeof(FRigidBodyState), Get_Z_Construct_UScriptStruct_FRigidBodyState_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FRigidBodyState(FRigidBodyState::StaticStruct, TEXT("/Script/Engine"), TEXT("RigidBodyState"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFRigidBodyState
{
	FScriptStruct_Engine_StaticRegisterNativesFRigidBodyState()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("RigidBodyState")),new UScriptStruct::TCppStructOps<FRigidBodyState>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFRigidBodyState;
	UScriptStruct* Z_Construct_UScriptStruct_FRigidBodyState()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FRigidBodyState_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RigidBodyState"), sizeof(FRigidBodyState), Get_Z_Construct_UScriptStruct_FRigidBodyState_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Describes the physical state of a rigid body." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FRigidBodyState>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Flags_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Flags = { UE4CodeGen_Private::EPropertyClass::Byte, "Flags", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyState, Flags), nullptr, METADATA_PARAMS(NewProp_Flags_MetaData, ARRAY_COUNT(NewProp_Flags_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_AngVel_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_AngVel = { UE4CodeGen_Private::EPropertyClass::Struct, "AngVel", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyState, AngVel), Z_Construct_UScriptStruct_FVector_NetQuantize100, METADATA_PARAMS(NewProp_AngVel_MetaData, ARRAY_COUNT(NewProp_AngVel_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_LinVel_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_LinVel = { UE4CodeGen_Private::EPropertyClass::Struct, "LinVel", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyState, LinVel), Z_Construct_UScriptStruct_FVector_NetQuantize100, METADATA_PARAMS(NewProp_LinVel_MetaData, ARRAY_COUNT(NewProp_LinVel_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Quaternion_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Quaternion = { UE4CodeGen_Private::EPropertyClass::Struct, "Quaternion", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyState, Quaternion), Z_Construct_UScriptStruct_FQuat, METADATA_PARAMS(NewProp_Quaternion_MetaData, ARRAY_COUNT(NewProp_Quaternion_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Position_MetaData[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FStructPropertyParams NewProp_Position = { UE4CodeGen_Private::EPropertyClass::Struct, "Position", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000000, 1, nullptr, STRUCT_OFFSET(FRigidBodyState, Position), Z_Construct_UScriptStruct_FVector_NetQuantize100, METADATA_PARAMS(NewProp_Position_MetaData, ARRAY_COUNT(NewProp_Position_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Flags,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_AngVel,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_LinVel,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Quaternion,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Position,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"RigidBodyState",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FRigidBodyState),
				alignof(FRigidBodyState),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRigidBodyState_CRC() { return 98231241U; }
class UScriptStruct* FCollisionResponseContainer::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FCollisionResponseContainer_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FCollisionResponseContainer, Z_Construct_UPackage__Script_Engine(), TEXT("CollisionResponseContainer"), sizeof(FCollisionResponseContainer), Get_Z_Construct_UScriptStruct_FCollisionResponseContainer_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FCollisionResponseContainer(FCollisionResponseContainer::StaticStruct, TEXT("/Script/Engine"), TEXT("CollisionResponseContainer"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFCollisionResponseContainer
{
	FScriptStruct_Engine_StaticRegisterNativesFCollisionResponseContainer()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("CollisionResponseContainer")),new UScriptStruct::TCppStructOps<FCollisionResponseContainer>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFCollisionResponseContainer;
	UScriptStruct* Z_Construct_UScriptStruct_FCollisionResponseContainer()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FCollisionResponseContainer_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("CollisionResponseContainer"), sizeof(FCollisionResponseContainer), Get_Z_Construct_UScriptStruct_FCollisionResponseContainer_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Container for indicating a set of collision channels that this object will collide with." },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FCollisionResponseContainer>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel18_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "30" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel18 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel18", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel18), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel18_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel18_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel17_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "28" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel17 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel17", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel17), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel17_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel17_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel16_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "28" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel16 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel16", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel16), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel16_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel16_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel15_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "27" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel15 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel15", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel15), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel15_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel15_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel14_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "26" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel14 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel14", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel14), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel14_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel14_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel13_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "25" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel13 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel13", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel13), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel13_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel13_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel12_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "24" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel12 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel12", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel12), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel12_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel12_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel11_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "23" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel11 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel11", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel11), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel11_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel11_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel10_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "22" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel10 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel10", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel10), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel10_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel10_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel9_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "21" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel9 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel9", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel9), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel9_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel9_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel8_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "20" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel8 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel8", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel8), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel8_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel8_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel7_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "19" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel7 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel7", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel7), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel7_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel7_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel6_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "18" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel6 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel6", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel6), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel6_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel6_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel5_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "17" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel5 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel5", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel5), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel5_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel5_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel4_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "16" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel4 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel4", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel4), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel4_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel4_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel3_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "15" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel3 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel3", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel3), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel3_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel3_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel2_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "14" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel2 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel2", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel2), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel2_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel2_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_GameTraceChannel1_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "in order to use this custom channels\nwe recommend to define in your local file\n- i.e. #define COLLISION_WEAPON               ECC_GameTraceChannel1\nand make sure you customize these it in INI file by\n\nin DefaultEngine.ini\n\n[/Script/Engine.CollisionProfile]\nGameTraceChannel1=\"Weapon\"\n\nalso in the INI file, you can override collision profiles that are defined by simply redefining\nnote that Weapon isn't defined in the BaseEngine.ini file, but \"Trigger\" is defined in Engine\n+Profiles=(Name=\"Trigger\",CollisionEnabled=QueryOnly,ObjectTypeName=WorldDynamic, DefaultResponse=ECR_Overlap, CustomResponses=((Channel=Visibility, Response=ECR_Ignore), (Channel=Weapon, Response=ECR_Ignore)))" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_GameTraceChannel1 = { UE4CodeGen_Private::EPropertyClass::Byte, "GameTraceChannel1", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, GameTraceChannel1), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_GameTraceChannel1_MetaData, ARRAY_COUNT(NewProp_GameTraceChannel1_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EngineTraceChannel6_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "12" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_EngineTraceChannel6 = { UE4CodeGen_Private::EPropertyClass::Byte, "EngineTraceChannel6", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, EngineTraceChannel6), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_EngineTraceChannel6_MetaData, ARRAY_COUNT(NewProp_EngineTraceChannel6_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EngineTraceChannel5_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "11" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_EngineTraceChannel5 = { UE4CodeGen_Private::EPropertyClass::Byte, "EngineTraceChannel5", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, EngineTraceChannel5), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_EngineTraceChannel5_MetaData, ARRAY_COUNT(NewProp_EngineTraceChannel5_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EngineTraceChannel4_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "10" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_EngineTraceChannel4 = { UE4CodeGen_Private::EPropertyClass::Byte, "EngineTraceChannel4", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, EngineTraceChannel4), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_EngineTraceChannel4_MetaData, ARRAY_COUNT(NewProp_EngineTraceChannel4_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EngineTraceChannel3_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "9" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_EngineTraceChannel3 = { UE4CodeGen_Private::EPropertyClass::Byte, "EngineTraceChannel3", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, EngineTraceChannel3), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_EngineTraceChannel3_MetaData, ARRAY_COUNT(NewProp_EngineTraceChannel3_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EngineTraceChannel2_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "8" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_EngineTraceChannel2 = { UE4CodeGen_Private::EPropertyClass::Byte, "EngineTraceChannel2", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, EngineTraceChannel2), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_EngineTraceChannel2_MetaData, ARRAY_COUNT(NewProp_EngineTraceChannel2_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_EngineTraceChannel1_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Unspecified Engine Trace Channels" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_EngineTraceChannel1 = { UE4CodeGen_Private::EPropertyClass::Byte, "EngineTraceChannel1", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, EngineTraceChannel1), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_EngineTraceChannel1_MetaData, ARRAY_COUNT(NewProp_EngineTraceChannel1_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Destructible_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "Destructible" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "6" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Destructible = { UE4CodeGen_Private::EPropertyClass::Byte, "Destructible", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, Destructible), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_Destructible_MetaData, ARRAY_COUNT(NewProp_Destructible_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Vehicle_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "Vehicle" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "5" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Vehicle = { UE4CodeGen_Private::EPropertyClass::Byte, "Vehicle", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, Vehicle), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_Vehicle_MetaData, ARRAY_COUNT(NewProp_Vehicle_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_PhysicsBody_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "PhysicsBody" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "4" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_PhysicsBody = { UE4CodeGen_Private::EPropertyClass::Byte, "PhysicsBody", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, PhysicsBody), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_PhysicsBody_MetaData, ARRAY_COUNT(NewProp_PhysicsBody_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Camera_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "Camera" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "3" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Camera = { UE4CodeGen_Private::EPropertyClass::Byte, "Camera", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, Camera), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_Camera_MetaData, ARRAY_COUNT(NewProp_Camera_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Visibility_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "Visibility" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "2" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Visibility = { UE4CodeGen_Private::EPropertyClass::Byte, "Visibility", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, Visibility), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_Visibility_MetaData, ARRAY_COUNT(NewProp_Visibility_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Pawn_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "Pawn" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "1." },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Pawn = { UE4CodeGen_Private::EPropertyClass::Byte, "Pawn", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, Pawn), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_Pawn_MetaData, ARRAY_COUNT(NewProp_Pawn_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_WorldDynamic_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "WorldDynamic" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "0" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_WorldDynamic = { UE4CodeGen_Private::EPropertyClass::Byte, "WorldDynamic", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, WorldDynamic), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_WorldDynamic_MetaData, ARRAY_COUNT(NewProp_WorldDynamic_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_WorldStatic_MetaData[] = {
				{ "Category", "CollisionResponseContainer" },
				{ "DisplayName", "WorldStatic" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Reserved Engine Trace Channels\n\nNote -        If you change this (add/remove/modify)\n                      you should make sure it matches with ECollisionChannel (including DisplayName)\n                      They has to be mirrored if serialized" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_WorldStatic = { UE4CodeGen_Private::EPropertyClass::Byte, "WorldStatic", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, STRUCT_OFFSET(FCollisionResponseContainer, WorldStatic), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_WorldStatic_MetaData, ARRAY_COUNT(NewProp_WorldStatic_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel18,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel17,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel16,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel15,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel14,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel13,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel12,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel11,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel10,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel9,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel8,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel7,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel6,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel5,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel4,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel3,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel2,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_GameTraceChannel1,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EngineTraceChannel6,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EngineTraceChannel5,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EngineTraceChannel4,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EngineTraceChannel3,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EngineTraceChannel2,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_EngineTraceChannel1,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Destructible,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Vehicle,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_PhysicsBody,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Camera,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Visibility,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Pawn,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_WorldDynamic,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_WorldStatic,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"CollisionResponseContainer",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000201),
				sizeof(FCollisionResponseContainer),
				alignof(FCollisionResponseContainer),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FCollisionResponseContainer_CRC() { return 3360863262U; }
class UScriptStruct* FResponseChannel::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FResponseChannel_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FResponseChannel, Z_Construct_UPackage__Script_Engine(), TEXT("ResponseChannel"), sizeof(FResponseChannel), Get_Z_Construct_UScriptStruct_FResponseChannel_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FResponseChannel(FResponseChannel::StaticStruct, TEXT("/Script/Engine"), TEXT("ResponseChannel"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFResponseChannel
{
	FScriptStruct_Engine_StaticRegisterNativesFResponseChannel()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("ResponseChannel")),new UScriptStruct::TCppStructOps<FResponseChannel>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFResponseChannel;
	UScriptStruct* Z_Construct_UScriptStruct_FResponseChannel()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FResponseChannel_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("ResponseChannel"), sizeof(FResponseChannel), Get_Z_Construct_UScriptStruct_FResponseChannel_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FResponseChannel>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Response_MetaData[] = {
				{ "Category", "FResponseChannel" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const UE4CodeGen_Private::FBytePropertyParams NewProp_Response = { UE4CodeGen_Private::EPropertyClass::Byte, "Response", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FResponseChannel, Response), Z_Construct_UEnum_Engine_ECollisionResponse, METADATA_PARAMS(NewProp_Response_MetaData, ARRAY_COUNT(NewProp_Response_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_Channel_MetaData[] = {
				{ "Category", "FResponseChannel" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "This should match DisplayName of ECollisionChannel\n    Meta data of custom channels can be used as well" },
			};
#endif
			static const UE4CodeGen_Private::FNamePropertyParams NewProp_Channel = { UE4CodeGen_Private::EPropertyClass::Name, "Channel", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000001, 1, nullptr, STRUCT_OFFSET(FResponseChannel, Channel), METADATA_PARAMS(NewProp_Channel_MetaData, ARRAY_COUNT(NewProp_Channel_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Response,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_Channel,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"ResponseChannel",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FResponseChannel),
				alignof(FResponseChannel),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FResponseChannel_CRC() { return 3627023055U; }
class UScriptStruct* FLightingChannels::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern ENGINE_API uint32 Get_Z_Construct_UScriptStruct_FLightingChannels_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FLightingChannels, Z_Construct_UPackage__Script_Engine(), TEXT("LightingChannels"), sizeof(FLightingChannels), Get_Z_Construct_UScriptStruct_FLightingChannels_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FLightingChannels(FLightingChannels::StaticStruct, TEXT("/Script/Engine"), TEXT("LightingChannels"), false, nullptr, nullptr);
static struct FScriptStruct_Engine_StaticRegisterNativesFLightingChannels
{
	FScriptStruct_Engine_StaticRegisterNativesFLightingChannels()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("LightingChannels")),new UScriptStruct::TCppStructOps<FLightingChannels>);
	}
} ScriptStruct_Engine_StaticRegisterNativesFLightingChannels;
	UScriptStruct* Z_Construct_UScriptStruct_FLightingChannels()
	{
#if WITH_HOT_RELOAD
		extern uint32 Get_Z_Construct_UScriptStruct_FLightingChannels_CRC();
		UPackage* Outer = Z_Construct_UPackage__Script_Engine();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LightingChannels"), sizeof(FLightingChannels), Get_Z_Construct_UScriptStruct_FLightingChannels_CRC(), false);
#else
		static UScriptStruct* ReturnStruct = nullptr;
#endif
		if (!ReturnStruct)
		{
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = {
				{ "BlueprintType", "true" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewStructOpsLambda = []() -> void* { return (UScriptStruct::ICppStructOps*)new UScriptStruct::TCppStructOps<FLightingChannels>(); };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bChannel2_MetaData[] = {
				{ "Category", "Channels" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewProp_bChannel2_SetBit = [](void* Obj){ ((FLightingChannels*)Obj)->bChannel2 = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bChannel2 = { UE4CodeGen_Private::EPropertyClass::Bool, "bChannel2", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightingChannels), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bChannel2_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bChannel2_MetaData, ARRAY_COUNT(NewProp_bChannel2_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bChannel1_MetaData[] = {
				{ "Category", "Channels" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			auto NewProp_bChannel1_SetBit = [](void* Obj){ ((FLightingChannels*)Obj)->bChannel1 = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bChannel1 = { UE4CodeGen_Private::EPropertyClass::Bool, "bChannel1", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightingChannels), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bChannel1_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bChannel1_MetaData, ARRAY_COUNT(NewProp_bChannel1_MetaData)) };
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam NewProp_bChannel0_MetaData[] = {
				{ "Category", "Channels" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
				{ "ToolTip", "Default channel for all primitives and lights." },
			};
#endif
			auto NewProp_bChannel0_SetBit = [](void* Obj){ ((FLightingChannels*)Obj)->bChannel0 = 1; };
			static const UE4CodeGen_Private::FBoolPropertyParams NewProp_bChannel0 = { UE4CodeGen_Private::EPropertyClass::Bool, "bChannel0", RF_Public|RF_Transient|RF_MarkAsNative, 0x0010000000000015, 1, nullptr, sizeof(uint8), UE4CodeGen_Private::ENativeBool::NotNative, sizeof(FLightingChannels), &UE4CodeGen_Private::TBoolSetBitWrapper<decltype(NewProp_bChannel0_SetBit)>::SetBit, METADATA_PARAMS(NewProp_bChannel0_MetaData, ARRAY_COUNT(NewProp_bChannel0_MetaData)) };
			static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[] = {
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bChannel2,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bChannel1,
				(const UE4CodeGen_Private::FPropertyParamsBase*)&NewProp_bChannel0,
			};
			static const UE4CodeGen_Private::FStructParams ReturnStructParams = {
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
				nullptr,
				&UE4CodeGen_Private::TNewCppStructOpsWrapper<decltype(NewStructOpsLambda)>::NewCppStructOps,
				"LightingChannels",
				RF_Public|RF_Transient|RF_MarkAsNative,
				EStructFlags(0x00000001),
				sizeof(FLightingChannels),
				alignof(FLightingChannels),
				PropPointers, ARRAY_COUNT(PropPointers),
				METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLightingChannels_CRC() { return 61234898U; }
	void UEngineTypes::StaticRegisterNativesUEngineTypes()
	{
	}
	UClass* Z_Construct_UClass_UEngineTypes_NoRegister()
	{
		return UEngineTypes::StaticClass();
	}
	UClass* Z_Construct_UClass_UEngineTypes()
	{
		static UClass* OuterClass = nullptr;
		if (!OuterClass)
		{
			static UObject* (*const DependentSingletons[])() = {
				(UObject* (*)())Z_Construct_UClass_UObject,
				(UObject* (*)())Z_Construct_UPackage__Script_Engine,
			};
#if WITH_METADATA
			static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
				{ "IncludePath", "Engine/EngineTypes.h" },
				{ "ModuleRelativePath", "Classes/Engine/EngineTypes.h" },
			};
#endif
			static const FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
				TCppClassTypeTraits<UEngineTypes>::IsAbstract,
			};
			static const UE4CodeGen_Private::FClassParams ClassParams = {
				&UEngineTypes::StaticClass,
				DependentSingletons, ARRAY_COUNT(DependentSingletons),
				0x00100081u,
				nullptr, 0,
				nullptr, 0,
				"Engine",
				&StaticCppClassTypeInfo,
				nullptr, 0,
				METADATA_PARAMS(Class_MetaDataParams, ARRAY_COUNT(Class_MetaDataParams))
			};
			UE4CodeGen_Private::ConstructUClass(OuterClass, ClassParams);
		}
		return OuterClass;
	}
	IMPLEMENT_CLASS(UEngineTypes, 2480876412);
	static FCompiledInDefer Z_CompiledInDefer_UClass_UEngineTypes(Z_Construct_UClass_UEngineTypes, &UEngineTypes::StaticClass, TEXT("/Script/Engine"), TEXT("UEngineTypes"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UEngineTypes);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif
